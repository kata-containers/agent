// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: oci.proto

package grpc

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import _ "github.com/golang/protobuf/ptypes/wrappers"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type Spec struct {
	// Version of the Open Container Initiative Runtime Specification with which the bundle complies.
	Version string `protobuf:"bytes,1,opt,name=Version,proto3" json:"Version,omitempty"`
	// Process configures the container process.
	Process *Process `protobuf:"bytes,2,opt,name=Process" json:"Process,omitempty"`
	// Root configures the container's root filesystem.
	Root *Root `protobuf:"bytes,3,opt,name=Root" json:"Root,omitempty"`
	// Hostname configures the container's hostname.
	Hostname string `protobuf:"bytes,4,opt,name=Hostname,proto3" json:"Hostname,omitempty"`
	// Mounts configures additional mounts (on top of Root).
	Mounts []Mount `protobuf:"bytes,5,rep,name=Mounts" json:"Mounts"`
	// Hooks configures callbacks for container lifecycle events.
	Hooks *Hooks `protobuf:"bytes,6,opt,name=Hooks" json:"Hooks,omitempty"`
	// Annotations contains arbitrary metadata for the container.
	Annotations map[string]string `protobuf:"bytes,7,rep,name=Annotations" json:"Annotations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Linux is platform-specific configuration for Linux based containers.
	Linux *Linux `protobuf:"bytes,8,opt,name=Linux" json:"Linux,omitempty"`
	// Solaris is platform-specific configuration for Solaris based containers.
	Solaris *Solaris `protobuf:"bytes,9,opt,name=Solaris" json:"Solaris,omitempty"`
	// Windows is platform-specific configuration for Windows based containers.
	Windows *Windows `protobuf:"bytes,10,opt,name=Windows" json:"Windows,omitempty"`
}

func (m *Spec) Reset()                    { *m = Spec{} }
func (m *Spec) String() string            { return proto.CompactTextString(m) }
func (*Spec) ProtoMessage()               {}
func (*Spec) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{0} }

func (m *Spec) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Spec) GetProcess() *Process {
	if m != nil {
		return m.Process
	}
	return nil
}

func (m *Spec) GetRoot() *Root {
	if m != nil {
		return m.Root
	}
	return nil
}

func (m *Spec) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *Spec) GetMounts() []Mount {
	if m != nil {
		return m.Mounts
	}
	return nil
}

func (m *Spec) GetHooks() *Hooks {
	if m != nil {
		return m.Hooks
	}
	return nil
}

func (m *Spec) GetAnnotations() map[string]string {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *Spec) GetLinux() *Linux {
	if m != nil {
		return m.Linux
	}
	return nil
}

func (m *Spec) GetSolaris() *Solaris {
	if m != nil {
		return m.Solaris
	}
	return nil
}

func (m *Spec) GetWindows() *Windows {
	if m != nil {
		return m.Windows
	}
	return nil
}

type Process struct {
	// Terminal creates an interactive terminal for the container.
	Terminal bool `protobuf:"varint,1,opt,name=Terminal,proto3" json:"Terminal,omitempty"`
	// ConsoleSize specifies the size of the console.
	ConsoleSize *Box `protobuf:"bytes,2,opt,name=ConsoleSize" json:"ConsoleSize,omitempty"`
	// User specifies user information for the process.
	User User `protobuf:"bytes,3,opt,name=User" json:"User"`
	// Args specifies the binary and arguments for the application to execute.
	Args []string `protobuf:"bytes,4,rep,name=Args" json:"Args,omitempty"`
	// Env populates the process environment for the process.
	Env []string `protobuf:"bytes,5,rep,name=Env" json:"Env,omitempty"`
	// Cwd is the current working directory for the process and must be
	// relative to the container's root.
	Cwd string `protobuf:"bytes,6,opt,name=Cwd,proto3" json:"Cwd,omitempty"`
	// Capabilities are Linux capabilities that are kept for the process.
	Capabilities *LinuxCapabilities `protobuf:"bytes,7,opt,name=Capabilities" json:"Capabilities,omitempty"`
	// Rlimits specifies rlimit options to apply to the process.
	Rlimits []POSIXRlimit `protobuf:"bytes,8,rep,name=Rlimits" json:"Rlimits"`
	// NoNewPrivileges controls whether additional privileges could be gained by processes in the container.
	NoNewPrivileges bool `protobuf:"varint,9,opt,name=NoNewPrivileges,proto3" json:"NoNewPrivileges,omitempty"`
	// ApparmorProfile specifies the apparmor profile for the container.
	ApparmorProfile string `protobuf:"bytes,10,opt,name=ApparmorProfile,proto3" json:"ApparmorProfile,omitempty"`
	// Specify an oom_score_adj for the container.
	OOMScoreAdj int64 `protobuf:"varint,11,opt,name=OOMScoreAdj,proto3" json:"OOMScoreAdj,omitempty"`
	// SelinuxLabel specifies the selinux context that the container process is run as.
	SelinuxLabel string `protobuf:"bytes,12,opt,name=SelinuxLabel,proto3" json:"SelinuxLabel,omitempty"`
}

func (m *Process) Reset()                    { *m = Process{} }
func (m *Process) String() string            { return proto.CompactTextString(m) }
func (*Process) ProtoMessage()               {}
func (*Process) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{1} }

func (m *Process) GetTerminal() bool {
	if m != nil {
		return m.Terminal
	}
	return false
}

func (m *Process) GetConsoleSize() *Box {
	if m != nil {
		return m.ConsoleSize
	}
	return nil
}

func (m *Process) GetUser() User {
	if m != nil {
		return m.User
	}
	return User{}
}

func (m *Process) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *Process) GetEnv() []string {
	if m != nil {
		return m.Env
	}
	return nil
}

func (m *Process) GetCwd() string {
	if m != nil {
		return m.Cwd
	}
	return ""
}

func (m *Process) GetCapabilities() *LinuxCapabilities {
	if m != nil {
		return m.Capabilities
	}
	return nil
}

func (m *Process) GetRlimits() []POSIXRlimit {
	if m != nil {
		return m.Rlimits
	}
	return nil
}

func (m *Process) GetNoNewPrivileges() bool {
	if m != nil {
		return m.NoNewPrivileges
	}
	return false
}

func (m *Process) GetApparmorProfile() string {
	if m != nil {
		return m.ApparmorProfile
	}
	return ""
}

func (m *Process) GetOOMScoreAdj() int64 {
	if m != nil {
		return m.OOMScoreAdj
	}
	return 0
}

func (m *Process) GetSelinuxLabel() string {
	if m != nil {
		return m.SelinuxLabel
	}
	return ""
}

type Box struct {
	// Height is the vertical dimension of a box.
	Height uint32 `protobuf:"varint,1,opt,name=Height,proto3" json:"Height,omitempty"`
	// Width is the horizontal dimension of a box.
	Width uint32 `protobuf:"varint,2,opt,name=Width,proto3" json:"Width,omitempty"`
}

func (m *Box) Reset()                    { *m = Box{} }
func (m *Box) String() string            { return proto.CompactTextString(m) }
func (*Box) ProtoMessage()               {}
func (*Box) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{2} }

func (m *Box) GetHeight() uint32 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *Box) GetWidth() uint32 {
	if m != nil {
		return m.Width
	}
	return 0
}

type User struct {
	// UID is the user id.
	UID uint32 `protobuf:"varint,1,opt,name=UID,proto3" json:"UID,omitempty"`
	// GID is the group id.
	GID uint32 `protobuf:"varint,2,opt,name=GID,proto3" json:"GID,omitempty"`
	// AdditionalGids are additional group ids set for the container's process.
	AdditionalGids []uint32 `protobuf:"varint,3,rep,packed,name=AdditionalGids" json:"AdditionalGids,omitempty"`
	// Username is the user name.
	Username string `protobuf:"bytes,4,opt,name=Username,proto3" json:"Username,omitempty"`
}

func (m *User) Reset()                    { *m = User{} }
func (m *User) String() string            { return proto.CompactTextString(m) }
func (*User) ProtoMessage()               {}
func (*User) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{3} }

func (m *User) GetUID() uint32 {
	if m != nil {
		return m.UID
	}
	return 0
}

func (m *User) GetGID() uint32 {
	if m != nil {
		return m.GID
	}
	return 0
}

func (m *User) GetAdditionalGids() []uint32 {
	if m != nil {
		return m.AdditionalGids
	}
	return nil
}

func (m *User) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

type LinuxCapabilities struct {
	// Bounding is the set of capabilities checked by the kernel.
	Bounding []string `protobuf:"bytes,1,rep,name=Bounding" json:"Bounding,omitempty"`
	// Effective is the set of capabilities checked by the kernel.
	Effective []string `protobuf:"bytes,2,rep,name=Effective" json:"Effective,omitempty"`
	// Inheritable is the capabilities preserved across execve.
	Inheritable []string `protobuf:"bytes,3,rep,name=Inheritable" json:"Inheritable,omitempty"`
	// Permitted is the limiting superset for effective capabilities.
	Permitted []string `protobuf:"bytes,4,rep,name=Permitted" json:"Permitted,omitempty"`
	// Ambient is the ambient set of capabilities that are kept.
	Ambient []string `protobuf:"bytes,5,rep,name=Ambient" json:"Ambient,omitempty"`
}

func (m *LinuxCapabilities) Reset()                    { *m = LinuxCapabilities{} }
func (m *LinuxCapabilities) String() string            { return proto.CompactTextString(m) }
func (*LinuxCapabilities) ProtoMessage()               {}
func (*LinuxCapabilities) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{4} }

func (m *LinuxCapabilities) GetBounding() []string {
	if m != nil {
		return m.Bounding
	}
	return nil
}

func (m *LinuxCapabilities) GetEffective() []string {
	if m != nil {
		return m.Effective
	}
	return nil
}

func (m *LinuxCapabilities) GetInheritable() []string {
	if m != nil {
		return m.Inheritable
	}
	return nil
}

func (m *LinuxCapabilities) GetPermitted() []string {
	if m != nil {
		return m.Permitted
	}
	return nil
}

func (m *LinuxCapabilities) GetAmbient() []string {
	if m != nil {
		return m.Ambient
	}
	return nil
}

type POSIXRlimit struct {
	// Type of the rlimit to set
	Type string `protobuf:"bytes,1,opt,name=Type,proto3" json:"Type,omitempty"`
	// Hard is the hard limit for the specified type
	Hard uint64 `protobuf:"varint,2,opt,name=Hard,proto3" json:"Hard,omitempty"`
	// Soft is the soft limit for the specified type
	Soft uint64 `protobuf:"varint,3,opt,name=Soft,proto3" json:"Soft,omitempty"`
}

func (m *POSIXRlimit) Reset()                    { *m = POSIXRlimit{} }
func (m *POSIXRlimit) String() string            { return proto.CompactTextString(m) }
func (*POSIXRlimit) ProtoMessage()               {}
func (*POSIXRlimit) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{5} }

func (m *POSIXRlimit) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *POSIXRlimit) GetHard() uint64 {
	if m != nil {
		return m.Hard
	}
	return 0
}

func (m *POSIXRlimit) GetSoft() uint64 {
	if m != nil {
		return m.Soft
	}
	return 0
}

type Mount struct {
	// destination is the path inside the container expect when it starts with "tmp:/"
	Destination string `protobuf:"bytes,1,opt,name=destination,proto3" json:"destination,omitempty"`
	// source is the path inside the container expect when it starts with "vm:/dev/" or "tmp:/"
	// the path which starts with "vm:/dev/" refers the guest vm's "/dev",
	// especially, "vm:/dev/hostfs/" refers to the shared filesystem.
	// "tmp:/" is a temporary directory which is used for temporary mounts.
	Source  string   `protobuf:"bytes,2,opt,name=source,proto3" json:"source,omitempty"`
	Type    string   `protobuf:"bytes,3,opt,name=type,proto3" json:"type,omitempty"`
	Options []string `protobuf:"bytes,4,rep,name=options" json:"options,omitempty"`
}

func (m *Mount) Reset()                    { *m = Mount{} }
func (m *Mount) String() string            { return proto.CompactTextString(m) }
func (*Mount) ProtoMessage()               {}
func (*Mount) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{6} }

func (m *Mount) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

func (m *Mount) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *Mount) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Mount) GetOptions() []string {
	if m != nil {
		return m.Options
	}
	return nil
}

type Root struct {
	// Path is the absolute path to the container's root filesystem.
	Path string `protobuf:"bytes,1,opt,name=Path,proto3" json:"Path,omitempty"`
	// Readonly makes the root filesystem for the container readonly before the process is executed.
	Readonly bool `protobuf:"varint,2,opt,name=Readonly,proto3" json:"Readonly,omitempty"`
}

func (m *Root) Reset()                    { *m = Root{} }
func (m *Root) String() string            { return proto.CompactTextString(m) }
func (*Root) ProtoMessage()               {}
func (*Root) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{7} }

func (m *Root) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *Root) GetReadonly() bool {
	if m != nil {
		return m.Readonly
	}
	return false
}

type Hooks struct {
	// Prestart is a list of hooks to be run before the container process is executed.
	Prestart []Hook `protobuf:"bytes,1,rep,name=Prestart" json:"Prestart"`
	// Poststart is a list of hooks to be run after the container process is started.
	Poststart []Hook `protobuf:"bytes,2,rep,name=Poststart" json:"Poststart"`
	// Poststop is a list of hooks to be run after the container process exits.
	Poststop []Hook `protobuf:"bytes,3,rep,name=Poststop" json:"Poststop"`
}

func (m *Hooks) Reset()                    { *m = Hooks{} }
func (m *Hooks) String() string            { return proto.CompactTextString(m) }
func (*Hooks) ProtoMessage()               {}
func (*Hooks) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{8} }

func (m *Hooks) GetPrestart() []Hook {
	if m != nil {
		return m.Prestart
	}
	return nil
}

func (m *Hooks) GetPoststart() []Hook {
	if m != nil {
		return m.Poststart
	}
	return nil
}

func (m *Hooks) GetPoststop() []Hook {
	if m != nil {
		return m.Poststop
	}
	return nil
}

type Hook struct {
	Path    string   `protobuf:"bytes,1,opt,name=Path,proto3" json:"Path,omitempty"`
	Args    []string `protobuf:"bytes,2,rep,name=Args" json:"Args,omitempty"`
	Env     []string `protobuf:"bytes,3,rep,name=Env" json:"Env,omitempty"`
	Timeout int64    `protobuf:"varint,4,opt,name=Timeout,proto3" json:"Timeout,omitempty"`
}

func (m *Hook) Reset()                    { *m = Hook{} }
func (m *Hook) String() string            { return proto.CompactTextString(m) }
func (*Hook) ProtoMessage()               {}
func (*Hook) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{9} }

func (m *Hook) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *Hook) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *Hook) GetEnv() []string {
	if m != nil {
		return m.Env
	}
	return nil
}

func (m *Hook) GetTimeout() int64 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

type Linux struct {
	// UIDMapping specifies user mappings for supporting user namespaces.
	UIDMappings []LinuxIDMapping `protobuf:"bytes,1,rep,name=UIDMappings" json:"UIDMappings"`
	// GIDMapping specifies group mappings for supporting user namespaces.
	GIDMappings []LinuxIDMapping `protobuf:"bytes,2,rep,name=GIDMappings" json:"GIDMappings"`
	// Sysctl are a set of key value pairs that are set for the container on start
	Sysctl map[string]string `protobuf:"bytes,3,rep,name=Sysctl" json:"Sysctl,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Resources contain cgroup information for handling resource constraints
	// for the container
	Resources *LinuxResources `protobuf:"bytes,4,opt,name=Resources" json:"Resources,omitempty"`
	// CgroupsPath specifies the path to cgroups that are created and/or joined by the container.
	// The path is expected to be relative to the cgroups mountpoint.
	// If resources are specified, the cgroups at CgroupsPath will be updated based on resources.
	CgroupsPath string `protobuf:"bytes,5,opt,name=CgroupsPath,proto3" json:"CgroupsPath,omitempty"`
	// Namespaces contains the namespaces that are created and/or joined by the container
	Namespaces []LinuxNamespace `protobuf:"bytes,6,rep,name=Namespaces" json:"Namespaces"`
	// Devices are a list of device nodes that are created for the container
	Devices []LinuxDevice `protobuf:"bytes,7,rep,name=Devices" json:"Devices"`
	// Seccomp specifies the seccomp security settings for the container.
	Seccomp *LinuxSeccomp `protobuf:"bytes,8,opt,name=Seccomp" json:"Seccomp,omitempty"`
	// RootfsPropagation is the rootfs mount propagation mode for the container.
	RootfsPropagation string `protobuf:"bytes,9,opt,name=RootfsPropagation,proto3" json:"RootfsPropagation,omitempty"`
	// MaskedPaths masks over the provided paths inside the container.
	MaskedPaths []string `protobuf:"bytes,10,rep,name=MaskedPaths" json:"MaskedPaths,omitempty"`
	// ReadonlyPaths sets the provided paths as RO inside the container.
	ReadonlyPaths []string `protobuf:"bytes,11,rep,name=ReadonlyPaths" json:"ReadonlyPaths,omitempty"`
	// MountLabel specifies the selinux context for the mounts in the container.
	MountLabel string `protobuf:"bytes,12,opt,name=MountLabel,proto3" json:"MountLabel,omitempty"`
	// IntelRdt contains Intel Resource Director Technology (RDT) information
	// for handling resource constraints (e.g., L3 cache) for the container
	IntelRdt *LinuxIntelRdt `protobuf:"bytes,13,opt,name=IntelRdt" json:"IntelRdt,omitempty"`
}

func (m *Linux) Reset()                    { *m = Linux{} }
func (m *Linux) String() string            { return proto.CompactTextString(m) }
func (*Linux) ProtoMessage()               {}
func (*Linux) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{10} }

func (m *Linux) GetUIDMappings() []LinuxIDMapping {
	if m != nil {
		return m.UIDMappings
	}
	return nil
}

func (m *Linux) GetGIDMappings() []LinuxIDMapping {
	if m != nil {
		return m.GIDMappings
	}
	return nil
}

func (m *Linux) GetSysctl() map[string]string {
	if m != nil {
		return m.Sysctl
	}
	return nil
}

func (m *Linux) GetResources() *LinuxResources {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *Linux) GetCgroupsPath() string {
	if m != nil {
		return m.CgroupsPath
	}
	return ""
}

func (m *Linux) GetNamespaces() []LinuxNamespace {
	if m != nil {
		return m.Namespaces
	}
	return nil
}

func (m *Linux) GetDevices() []LinuxDevice {
	if m != nil {
		return m.Devices
	}
	return nil
}

func (m *Linux) GetSeccomp() *LinuxSeccomp {
	if m != nil {
		return m.Seccomp
	}
	return nil
}

func (m *Linux) GetRootfsPropagation() string {
	if m != nil {
		return m.RootfsPropagation
	}
	return ""
}

func (m *Linux) GetMaskedPaths() []string {
	if m != nil {
		return m.MaskedPaths
	}
	return nil
}

func (m *Linux) GetReadonlyPaths() []string {
	if m != nil {
		return m.ReadonlyPaths
	}
	return nil
}

func (m *Linux) GetMountLabel() string {
	if m != nil {
		return m.MountLabel
	}
	return ""
}

func (m *Linux) GetIntelRdt() *LinuxIntelRdt {
	if m != nil {
		return m.IntelRdt
	}
	return nil
}

type Windows struct {
	// Dummy string, never used.
	Dummy string `protobuf:"bytes,1,opt,name=dummy,proto3" json:"dummy,omitempty"`
}

func (m *Windows) Reset()                    { *m = Windows{} }
func (m *Windows) String() string            { return proto.CompactTextString(m) }
func (*Windows) ProtoMessage()               {}
func (*Windows) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{11} }

func (m *Windows) GetDummy() string {
	if m != nil {
		return m.Dummy
	}
	return ""
}

type Solaris struct {
	// Dummy string, never used.
	Dummy string `protobuf:"bytes,1,opt,name=dummy,proto3" json:"dummy,omitempty"`
}

func (m *Solaris) Reset()                    { *m = Solaris{} }
func (m *Solaris) String() string            { return proto.CompactTextString(m) }
func (*Solaris) ProtoMessage()               {}
func (*Solaris) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{12} }

func (m *Solaris) GetDummy() string {
	if m != nil {
		return m.Dummy
	}
	return ""
}

type LinuxIDMapping struct {
	// HostID is the starting UID/GID on the host to be mapped to 'ContainerID'
	HostID uint32 `protobuf:"varint,1,opt,name=HostID,proto3" json:"HostID,omitempty"`
	// ContainerID is the starting UID/GID in the container
	ContainerID uint32 `protobuf:"varint,2,opt,name=ContainerID,proto3" json:"ContainerID,omitempty"`
	// Size is the number of IDs to be mapped
	Size_ uint32 `protobuf:"varint,3,opt,name=Size,proto3" json:"Size,omitempty"`
}

func (m *LinuxIDMapping) Reset()                    { *m = LinuxIDMapping{} }
func (m *LinuxIDMapping) String() string            { return proto.CompactTextString(m) }
func (*LinuxIDMapping) ProtoMessage()               {}
func (*LinuxIDMapping) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{13} }

func (m *LinuxIDMapping) GetHostID() uint32 {
	if m != nil {
		return m.HostID
	}
	return 0
}

func (m *LinuxIDMapping) GetContainerID() uint32 {
	if m != nil {
		return m.ContainerID
	}
	return 0
}

func (m *LinuxIDMapping) GetSize_() uint32 {
	if m != nil {
		return m.Size_
	}
	return 0
}

type LinuxNamespace struct {
	// Type is the type of namespace
	Type string `protobuf:"bytes,1,opt,name=Type,proto3" json:"Type,omitempty"`
	// Path is a path to an existing namespace persisted on disk that can be joined
	// and is of the same type
	Path string `protobuf:"bytes,2,opt,name=Path,proto3" json:"Path,omitempty"`
}

func (m *LinuxNamespace) Reset()                    { *m = LinuxNamespace{} }
func (m *LinuxNamespace) String() string            { return proto.CompactTextString(m) }
func (*LinuxNamespace) ProtoMessage()               {}
func (*LinuxNamespace) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{14} }

func (m *LinuxNamespace) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *LinuxNamespace) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

type LinuxDevice struct {
	// Path to the device.
	Path string `protobuf:"bytes,1,opt,name=Path,proto3" json:"Path,omitempty"`
	// Device type, block, char, etc.
	Type string `protobuf:"bytes,2,opt,name=Type,proto3" json:"Type,omitempty"`
	// Major is the device's major number.
	Major int64 `protobuf:"varint,3,opt,name=Major,proto3" json:"Major,omitempty"`
	// Minor is the device's minor number.
	Minor int64 `protobuf:"varint,4,opt,name=Minor,proto3" json:"Minor,omitempty"`
	// FileMode permission bits for the device.
	FileMode uint32 `protobuf:"varint,5,opt,name=FileMode,proto3" json:"FileMode,omitempty"`
	// UID of the device.
	UID uint32 `protobuf:"varint,6,opt,name=UID,proto3" json:"UID,omitempty"`
	// Gid of the device.
	GID uint32 `protobuf:"varint,7,opt,name=GID,proto3" json:"GID,omitempty"`
}

func (m *LinuxDevice) Reset()                    { *m = LinuxDevice{} }
func (m *LinuxDevice) String() string            { return proto.CompactTextString(m) }
func (*LinuxDevice) ProtoMessage()               {}
func (*LinuxDevice) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{15} }

func (m *LinuxDevice) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *LinuxDevice) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *LinuxDevice) GetMajor() int64 {
	if m != nil {
		return m.Major
	}
	return 0
}

func (m *LinuxDevice) GetMinor() int64 {
	if m != nil {
		return m.Minor
	}
	return 0
}

func (m *LinuxDevice) GetFileMode() uint32 {
	if m != nil {
		return m.FileMode
	}
	return 0
}

func (m *LinuxDevice) GetUID() uint32 {
	if m != nil {
		return m.UID
	}
	return 0
}

func (m *LinuxDevice) GetGID() uint32 {
	if m != nil {
		return m.GID
	}
	return 0
}

type LinuxResources struct {
	// Devices configures the device whitelist.
	Devices []LinuxDeviceCgroup `protobuf:"bytes,1,rep,name=Devices" json:"Devices"`
	// Memory restriction configuration
	Memory *LinuxMemory `protobuf:"bytes,2,opt,name=Memory" json:"Memory,omitempty"`
	// CPU resource restriction configuration
	CPU *LinuxCPU `protobuf:"bytes,3,opt,name=CPU" json:"CPU,omitempty"`
	// Task resource restriction configuration.
	Pids *LinuxPids `protobuf:"bytes,4,opt,name=Pids" json:"Pids,omitempty"`
	// BlockIO restriction configuration
	BlockIO *LinuxBlockIO `protobuf:"bytes,5,opt,name=BlockIO" json:"BlockIO,omitempty"`
	// Hugetlb limit (in bytes)
	HugepageLimits []LinuxHugepageLimit `protobuf:"bytes,6,rep,name=HugepageLimits" json:"HugepageLimits"`
	// Network restriction configuration
	Network *LinuxNetwork `protobuf:"bytes,7,opt,name=Network" json:"Network,omitempty"`
}

func (m *LinuxResources) Reset()                    { *m = LinuxResources{} }
func (m *LinuxResources) String() string            { return proto.CompactTextString(m) }
func (*LinuxResources) ProtoMessage()               {}
func (*LinuxResources) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{16} }

func (m *LinuxResources) GetDevices() []LinuxDeviceCgroup {
	if m != nil {
		return m.Devices
	}
	return nil
}

func (m *LinuxResources) GetMemory() *LinuxMemory {
	if m != nil {
		return m.Memory
	}
	return nil
}

func (m *LinuxResources) GetCPU() *LinuxCPU {
	if m != nil {
		return m.CPU
	}
	return nil
}

func (m *LinuxResources) GetPids() *LinuxPids {
	if m != nil {
		return m.Pids
	}
	return nil
}

func (m *LinuxResources) GetBlockIO() *LinuxBlockIO {
	if m != nil {
		return m.BlockIO
	}
	return nil
}

func (m *LinuxResources) GetHugepageLimits() []LinuxHugepageLimit {
	if m != nil {
		return m.HugepageLimits
	}
	return nil
}

func (m *LinuxResources) GetNetwork() *LinuxNetwork {
	if m != nil {
		return m.Network
	}
	return nil
}

type LinuxMemory struct {
	// Memory limit (in bytes).
	Limit int64 `protobuf:"varint,1,opt,name=Limit,proto3" json:"Limit,omitempty"`
	// Memory reservation or soft_limit (in bytes).
	Reservation int64 `protobuf:"varint,2,opt,name=Reservation,proto3" json:"Reservation,omitempty"`
	// Total memory limit (memory + swap).
	Swap int64 `protobuf:"varint,3,opt,name=Swap,proto3" json:"Swap,omitempty"`
	// Kernel memory limit (in bytes).
	Kernel int64 `protobuf:"varint,4,opt,name=Kernel,proto3" json:"Kernel,omitempty"`
	// Kernel memory limit for tcp (in bytes)
	KernelTCP int64 `protobuf:"varint,5,opt,name=KernelTCP,proto3" json:"KernelTCP,omitempty"`
	// How aggressive the kernel will swap memory pages.
	Swappiness uint64 `protobuf:"varint,6,opt,name=Swappiness,proto3" json:"Swappiness,omitempty"`
	// DisableOOMKiller disables the OOM killer for out of memory conditions
	DisableOOMKiller bool `protobuf:"varint,7,opt,name=DisableOOMKiller,proto3" json:"DisableOOMKiller,omitempty"`
}

func (m *LinuxMemory) Reset()                    { *m = LinuxMemory{} }
func (m *LinuxMemory) String() string            { return proto.CompactTextString(m) }
func (*LinuxMemory) ProtoMessage()               {}
func (*LinuxMemory) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{17} }

func (m *LinuxMemory) GetLimit() int64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *LinuxMemory) GetReservation() int64 {
	if m != nil {
		return m.Reservation
	}
	return 0
}

func (m *LinuxMemory) GetSwap() int64 {
	if m != nil {
		return m.Swap
	}
	return 0
}

func (m *LinuxMemory) GetKernel() int64 {
	if m != nil {
		return m.Kernel
	}
	return 0
}

func (m *LinuxMemory) GetKernelTCP() int64 {
	if m != nil {
		return m.KernelTCP
	}
	return 0
}

func (m *LinuxMemory) GetSwappiness() uint64 {
	if m != nil {
		return m.Swappiness
	}
	return 0
}

func (m *LinuxMemory) GetDisableOOMKiller() bool {
	if m != nil {
		return m.DisableOOMKiller
	}
	return false
}

type LinuxCPU struct {
	// CPU shares (relative weight (ratio) vs. other cgroups with cpu shares).
	Shares uint64 `protobuf:"varint,1,opt,name=Shares,proto3" json:"Shares,omitempty"`
	// CPU hardcap limit (in usecs). Allowed cpu time in a given period.
	Quota int64 `protobuf:"varint,2,opt,name=Quota,proto3" json:"Quota,omitempty"`
	// CPU period to be used for hardcapping (in usecs).
	Period uint64 `protobuf:"varint,3,opt,name=Period,proto3" json:"Period,omitempty"`
	// How much time realtime scheduling may use (in usecs).
	RealtimeRuntime int64 `protobuf:"varint,4,opt,name=RealtimeRuntime,proto3" json:"RealtimeRuntime,omitempty"`
	// CPU period to be used for realtime scheduling (in usecs).
	RealtimePeriod uint64 `protobuf:"varint,5,opt,name=RealtimePeriod,proto3" json:"RealtimePeriod,omitempty"`
	// CPUs to use within the cpuset. Default is to use any CPU available.
	Cpus string `protobuf:"bytes,6,opt,name=Cpus,proto3" json:"Cpus,omitempty"`
	// List of memory nodes in the cpuset. Default is to use any available memory node.
	Mems string `protobuf:"bytes,7,opt,name=Mems,proto3" json:"Mems,omitempty"`
}

func (m *LinuxCPU) Reset()                    { *m = LinuxCPU{} }
func (m *LinuxCPU) String() string            { return proto.CompactTextString(m) }
func (*LinuxCPU) ProtoMessage()               {}
func (*LinuxCPU) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{18} }

func (m *LinuxCPU) GetShares() uint64 {
	if m != nil {
		return m.Shares
	}
	return 0
}

func (m *LinuxCPU) GetQuota() int64 {
	if m != nil {
		return m.Quota
	}
	return 0
}

func (m *LinuxCPU) GetPeriod() uint64 {
	if m != nil {
		return m.Period
	}
	return 0
}

func (m *LinuxCPU) GetRealtimeRuntime() int64 {
	if m != nil {
		return m.RealtimeRuntime
	}
	return 0
}

func (m *LinuxCPU) GetRealtimePeriod() uint64 {
	if m != nil {
		return m.RealtimePeriod
	}
	return 0
}

func (m *LinuxCPU) GetCpus() string {
	if m != nil {
		return m.Cpus
	}
	return ""
}

func (m *LinuxCPU) GetMems() string {
	if m != nil {
		return m.Mems
	}
	return ""
}

type LinuxWeightDevice struct {
	// Major is the device's major number.
	Major int64 `protobuf:"varint,1,opt,name=Major,proto3" json:"Major,omitempty"`
	// Minor is the device's minor number.
	Minor int64 `protobuf:"varint,2,opt,name=Minor,proto3" json:"Minor,omitempty"`
	// Weight is the bandwidth rate for the device.
	Weight uint32 `protobuf:"varint,3,opt,name=Weight,proto3" json:"Weight,omitempty"`
	// LeafWeight is the bandwidth rate for the device while competing with the cgroup's child cgroups, CFQ scheduler only
	LeafWeight uint32 `protobuf:"varint,4,opt,name=LeafWeight,proto3" json:"LeafWeight,omitempty"`
}

func (m *LinuxWeightDevice) Reset()                    { *m = LinuxWeightDevice{} }
func (m *LinuxWeightDevice) String() string            { return proto.CompactTextString(m) }
func (*LinuxWeightDevice) ProtoMessage()               {}
func (*LinuxWeightDevice) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{19} }

func (m *LinuxWeightDevice) GetMajor() int64 {
	if m != nil {
		return m.Major
	}
	return 0
}

func (m *LinuxWeightDevice) GetMinor() int64 {
	if m != nil {
		return m.Minor
	}
	return 0
}

func (m *LinuxWeightDevice) GetWeight() uint32 {
	if m != nil {
		return m.Weight
	}
	return 0
}

func (m *LinuxWeightDevice) GetLeafWeight() uint32 {
	if m != nil {
		return m.LeafWeight
	}
	return 0
}

type LinuxThrottleDevice struct {
	// Major is the device's major number.
	Major int64 `protobuf:"varint,1,opt,name=Major,proto3" json:"Major,omitempty"`
	// Minor is the device's minor number.
	Minor int64 `protobuf:"varint,2,opt,name=Minor,proto3" json:"Minor,omitempty"`
	// Rate is the IO rate limit per cgroup per device
	Rate uint64 `protobuf:"varint,3,opt,name=Rate,proto3" json:"Rate,omitempty"`
}

func (m *LinuxThrottleDevice) Reset()                    { *m = LinuxThrottleDevice{} }
func (m *LinuxThrottleDevice) String() string            { return proto.CompactTextString(m) }
func (*LinuxThrottleDevice) ProtoMessage()               {}
func (*LinuxThrottleDevice) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{20} }

func (m *LinuxThrottleDevice) GetMajor() int64 {
	if m != nil {
		return m.Major
	}
	return 0
}

func (m *LinuxThrottleDevice) GetMinor() int64 {
	if m != nil {
		return m.Minor
	}
	return 0
}

func (m *LinuxThrottleDevice) GetRate() uint64 {
	if m != nil {
		return m.Rate
	}
	return 0
}

type LinuxBlockIO struct {
	// Specifies per cgroup weight
	Weight uint32 `protobuf:"varint,1,opt,name=Weight,proto3" json:"Weight,omitempty"`
	// Specifies tasks' weight in the given cgroup while competing with the cgroup's child cgroups, CFQ scheduler only
	LeafWeight uint32 `protobuf:"varint,2,opt,name=LeafWeight,proto3" json:"LeafWeight,omitempty"`
	// Weight per cgroup per device, can override BlkioWeight
	WeightDevice []LinuxWeightDevice `protobuf:"bytes,3,rep,name=WeightDevice" json:"WeightDevice"`
	// IO read rate limit per cgroup per device, bytes per second
	ThrottleReadBpsDevice []LinuxThrottleDevice `protobuf:"bytes,4,rep,name=ThrottleReadBpsDevice" json:"ThrottleReadBpsDevice"`
	// IO write rate limit per cgroup per device, bytes per second
	ThrottleWriteBpsDevice []LinuxThrottleDevice `protobuf:"bytes,5,rep,name=ThrottleWriteBpsDevice" json:"ThrottleWriteBpsDevice"`
	// IO read rate limit per cgroup per device, IO per second
	ThrottleReadIOPSDevice []LinuxThrottleDevice `protobuf:"bytes,6,rep,name=ThrottleReadIOPSDevice" json:"ThrottleReadIOPSDevice"`
	// IO write rate limit per cgroup per device, IO per second
	ThrottleWriteIOPSDevice []LinuxThrottleDevice `protobuf:"bytes,7,rep,name=ThrottleWriteIOPSDevice" json:"ThrottleWriteIOPSDevice"`
}

func (m *LinuxBlockIO) Reset()                    { *m = LinuxBlockIO{} }
func (m *LinuxBlockIO) String() string            { return proto.CompactTextString(m) }
func (*LinuxBlockIO) ProtoMessage()               {}
func (*LinuxBlockIO) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{21} }

func (m *LinuxBlockIO) GetWeight() uint32 {
	if m != nil {
		return m.Weight
	}
	return 0
}

func (m *LinuxBlockIO) GetLeafWeight() uint32 {
	if m != nil {
		return m.LeafWeight
	}
	return 0
}

func (m *LinuxBlockIO) GetWeightDevice() []LinuxWeightDevice {
	if m != nil {
		return m.WeightDevice
	}
	return nil
}

func (m *LinuxBlockIO) GetThrottleReadBpsDevice() []LinuxThrottleDevice {
	if m != nil {
		return m.ThrottleReadBpsDevice
	}
	return nil
}

func (m *LinuxBlockIO) GetThrottleWriteBpsDevice() []LinuxThrottleDevice {
	if m != nil {
		return m.ThrottleWriteBpsDevice
	}
	return nil
}

func (m *LinuxBlockIO) GetThrottleReadIOPSDevice() []LinuxThrottleDevice {
	if m != nil {
		return m.ThrottleReadIOPSDevice
	}
	return nil
}

func (m *LinuxBlockIO) GetThrottleWriteIOPSDevice() []LinuxThrottleDevice {
	if m != nil {
		return m.ThrottleWriteIOPSDevice
	}
	return nil
}

type LinuxPids struct {
	// Maximum number of PIDs. Default is "no limit".
	Limit int64 `protobuf:"varint,1,opt,name=Limit,proto3" json:"Limit,omitempty"`
}

func (m *LinuxPids) Reset()                    { *m = LinuxPids{} }
func (m *LinuxPids) String() string            { return proto.CompactTextString(m) }
func (*LinuxPids) ProtoMessage()               {}
func (*LinuxPids) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{22} }

func (m *LinuxPids) GetLimit() int64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type LinuxDeviceCgroup struct {
	// Allow or deny
	Allow bool `protobuf:"varint,1,opt,name=Allow,proto3" json:"Allow,omitempty"`
	// Device type, block, char, etc.
	Type string `protobuf:"bytes,2,opt,name=Type,proto3" json:"Type,omitempty"`
	// Major is the device's major number.
	Major int64 `protobuf:"varint,3,opt,name=Major,proto3" json:"Major,omitempty"`
	// Minor is the device's minor number.
	Minor int64 `protobuf:"varint,4,opt,name=Minor,proto3" json:"Minor,omitempty"`
	// Cgroup access permissions format, rwm.
	Access string `protobuf:"bytes,5,opt,name=Access,proto3" json:"Access,omitempty"`
}

func (m *LinuxDeviceCgroup) Reset()                    { *m = LinuxDeviceCgroup{} }
func (m *LinuxDeviceCgroup) String() string            { return proto.CompactTextString(m) }
func (*LinuxDeviceCgroup) ProtoMessage()               {}
func (*LinuxDeviceCgroup) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{23} }

func (m *LinuxDeviceCgroup) GetAllow() bool {
	if m != nil {
		return m.Allow
	}
	return false
}

func (m *LinuxDeviceCgroup) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *LinuxDeviceCgroup) GetMajor() int64 {
	if m != nil {
		return m.Major
	}
	return 0
}

func (m *LinuxDeviceCgroup) GetMinor() int64 {
	if m != nil {
		return m.Minor
	}
	return 0
}

func (m *LinuxDeviceCgroup) GetAccess() string {
	if m != nil {
		return m.Access
	}
	return ""
}

type LinuxNetwork struct {
	// Set class identifier for container's network packets
	ClassID uint32 `protobuf:"varint,1,opt,name=ClassID,proto3" json:"ClassID,omitempty"`
	// Set priority of network traffic for container
	Priorities []LinuxInterfacePriority `protobuf:"bytes,2,rep,name=Priorities" json:"Priorities"`
}

func (m *LinuxNetwork) Reset()                    { *m = LinuxNetwork{} }
func (m *LinuxNetwork) String() string            { return proto.CompactTextString(m) }
func (*LinuxNetwork) ProtoMessage()               {}
func (*LinuxNetwork) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{24} }

func (m *LinuxNetwork) GetClassID() uint32 {
	if m != nil {
		return m.ClassID
	}
	return 0
}

func (m *LinuxNetwork) GetPriorities() []LinuxInterfacePriority {
	if m != nil {
		return m.Priorities
	}
	return nil
}

type LinuxHugepageLimit struct {
	// Pagesize is the hugepage size
	Pagesize string `protobuf:"bytes,1,opt,name=Pagesize,proto3" json:"Pagesize,omitempty"`
	// Limit is the limit of "hugepagesize" hugetlb usage
	Limit uint64 `protobuf:"varint,2,opt,name=Limit,proto3" json:"Limit,omitempty"`
}

func (m *LinuxHugepageLimit) Reset()                    { *m = LinuxHugepageLimit{} }
func (m *LinuxHugepageLimit) String() string            { return proto.CompactTextString(m) }
func (*LinuxHugepageLimit) ProtoMessage()               {}
func (*LinuxHugepageLimit) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{25} }

func (m *LinuxHugepageLimit) GetPagesize() string {
	if m != nil {
		return m.Pagesize
	}
	return ""
}

func (m *LinuxHugepageLimit) GetLimit() uint64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type LinuxInterfacePriority struct {
	// Name is the name of the network interface
	Name string `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	// Priority for the interface
	Priority uint32 `protobuf:"varint,2,opt,name=Priority,proto3" json:"Priority,omitempty"`
}

func (m *LinuxInterfacePriority) Reset()                    { *m = LinuxInterfacePriority{} }
func (m *LinuxInterfacePriority) String() string            { return proto.CompactTextString(m) }
func (*LinuxInterfacePriority) ProtoMessage()               {}
func (*LinuxInterfacePriority) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{26} }

func (m *LinuxInterfacePriority) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *LinuxInterfacePriority) GetPriority() uint32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

type LinuxSeccomp struct {
	DefaultAction string         `protobuf:"bytes,1,opt,name=DefaultAction,proto3" json:"DefaultAction,omitempty"`
	Architectures []string       `protobuf:"bytes,2,rep,name=Architectures" json:"Architectures,omitempty"`
	Syscalls      []LinuxSyscall `protobuf:"bytes,3,rep,name=Syscalls" json:"Syscalls"`
}

func (m *LinuxSeccomp) Reset()                    { *m = LinuxSeccomp{} }
func (m *LinuxSeccomp) String() string            { return proto.CompactTextString(m) }
func (*LinuxSeccomp) ProtoMessage()               {}
func (*LinuxSeccomp) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{27} }

func (m *LinuxSeccomp) GetDefaultAction() string {
	if m != nil {
		return m.DefaultAction
	}
	return ""
}

func (m *LinuxSeccomp) GetArchitectures() []string {
	if m != nil {
		return m.Architectures
	}
	return nil
}

func (m *LinuxSeccomp) GetSyscalls() []LinuxSyscall {
	if m != nil {
		return m.Syscalls
	}
	return nil
}

type LinuxSeccompArg struct {
	Index    uint64 `protobuf:"varint,1,opt,name=Index,proto3" json:"Index,omitempty"`
	Value    uint64 `protobuf:"varint,2,opt,name=Value,proto3" json:"Value,omitempty"`
	ValueTwo uint64 `protobuf:"varint,3,opt,name=ValueTwo,proto3" json:"ValueTwo,omitempty"`
	Op       string `protobuf:"bytes,4,opt,name=Op,proto3" json:"Op,omitempty"`
}

func (m *LinuxSeccompArg) Reset()                    { *m = LinuxSeccompArg{} }
func (m *LinuxSeccompArg) String() string            { return proto.CompactTextString(m) }
func (*LinuxSeccompArg) ProtoMessage()               {}
func (*LinuxSeccompArg) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{28} }

func (m *LinuxSeccompArg) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *LinuxSeccompArg) GetValue() uint64 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *LinuxSeccompArg) GetValueTwo() uint64 {
	if m != nil {
		return m.ValueTwo
	}
	return 0
}

func (m *LinuxSeccompArg) GetOp() string {
	if m != nil {
		return m.Op
	}
	return ""
}

type LinuxSyscall struct {
	Names  []string          `protobuf:"bytes,1,rep,name=Names" json:"Names,omitempty"`
	Action string            `protobuf:"bytes,2,opt,name=Action,proto3" json:"Action,omitempty"`
	Args   []LinuxSeccompArg `protobuf:"bytes,3,rep,name=Args" json:"Args"`
}

func (m *LinuxSyscall) Reset()                    { *m = LinuxSyscall{} }
func (m *LinuxSyscall) String() string            { return proto.CompactTextString(m) }
func (*LinuxSyscall) ProtoMessage()               {}
func (*LinuxSyscall) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{29} }

func (m *LinuxSyscall) GetNames() []string {
	if m != nil {
		return m.Names
	}
	return nil
}

func (m *LinuxSyscall) GetAction() string {
	if m != nil {
		return m.Action
	}
	return ""
}

func (m *LinuxSyscall) GetArgs() []LinuxSeccompArg {
	if m != nil {
		return m.Args
	}
	return nil
}

type LinuxIntelRdt struct {
	// The schema for L3 cache id and capacity bitmask (CBM)
	// Format: "L3:<cache_id0>=<cbm0>;<cache_id1>=<cbm1>;..."
	L3CacheSchema string `protobuf:"bytes,1,opt,name=L3CacheSchema,proto3" json:"L3CacheSchema,omitempty"`
}

func (m *LinuxIntelRdt) Reset()                    { *m = LinuxIntelRdt{} }
func (m *LinuxIntelRdt) String() string            { return proto.CompactTextString(m) }
func (*LinuxIntelRdt) ProtoMessage()               {}
func (*LinuxIntelRdt) Descriptor() ([]byte, []int) { return fileDescriptorOci, []int{30} }

func (m *LinuxIntelRdt) GetL3CacheSchema() string {
	if m != nil {
		return m.L3CacheSchema
	}
	return ""
}

func init() {
	proto.RegisterType((*Spec)(nil), "grpc.Spec")
	proto.RegisterType((*Process)(nil), "grpc.Process")
	proto.RegisterType((*Box)(nil), "grpc.Box")
	proto.RegisterType((*User)(nil), "grpc.User")
	proto.RegisterType((*LinuxCapabilities)(nil), "grpc.LinuxCapabilities")
	proto.RegisterType((*POSIXRlimit)(nil), "grpc.POSIXRlimit")
	proto.RegisterType((*Mount)(nil), "grpc.Mount")
	proto.RegisterType((*Root)(nil), "grpc.Root")
	proto.RegisterType((*Hooks)(nil), "grpc.Hooks")
	proto.RegisterType((*Hook)(nil), "grpc.Hook")
	proto.RegisterType((*Linux)(nil), "grpc.Linux")
	proto.RegisterType((*Windows)(nil), "grpc.Windows")
	proto.RegisterType((*Solaris)(nil), "grpc.Solaris")
	proto.RegisterType((*LinuxIDMapping)(nil), "grpc.LinuxIDMapping")
	proto.RegisterType((*LinuxNamespace)(nil), "grpc.LinuxNamespace")
	proto.RegisterType((*LinuxDevice)(nil), "grpc.LinuxDevice")
	proto.RegisterType((*LinuxResources)(nil), "grpc.LinuxResources")
	proto.RegisterType((*LinuxMemory)(nil), "grpc.LinuxMemory")
	proto.RegisterType((*LinuxCPU)(nil), "grpc.LinuxCPU")
	proto.RegisterType((*LinuxWeightDevice)(nil), "grpc.LinuxWeightDevice")
	proto.RegisterType((*LinuxThrottleDevice)(nil), "grpc.LinuxThrottleDevice")
	proto.RegisterType((*LinuxBlockIO)(nil), "grpc.LinuxBlockIO")
	proto.RegisterType((*LinuxPids)(nil), "grpc.LinuxPids")
	proto.RegisterType((*LinuxDeviceCgroup)(nil), "grpc.LinuxDeviceCgroup")
	proto.RegisterType((*LinuxNetwork)(nil), "grpc.LinuxNetwork")
	proto.RegisterType((*LinuxHugepageLimit)(nil), "grpc.LinuxHugepageLimit")
	proto.RegisterType((*LinuxInterfacePriority)(nil), "grpc.LinuxInterfacePriority")
	proto.RegisterType((*LinuxSeccomp)(nil), "grpc.LinuxSeccomp")
	proto.RegisterType((*LinuxSeccompArg)(nil), "grpc.LinuxSeccompArg")
	proto.RegisterType((*LinuxSyscall)(nil), "grpc.LinuxSyscall")
	proto.RegisterType((*LinuxIntelRdt)(nil), "grpc.LinuxIntelRdt")
}
func (this *Spec) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Spec)
	if !ok {
		that2, ok := that.(Spec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if !this.Process.Equal(that1.Process) {
		return false
	}
	if !this.Root.Equal(that1.Root) {
		return false
	}
	if this.Hostname != that1.Hostname {
		return false
	}
	if len(this.Mounts) != len(that1.Mounts) {
		return false
	}
	for i := range this.Mounts {
		if !this.Mounts[i].Equal(&that1.Mounts[i]) {
			return false
		}
	}
	if !this.Hooks.Equal(that1.Hooks) {
		return false
	}
	if len(this.Annotations) != len(that1.Annotations) {
		return false
	}
	for i := range this.Annotations {
		if this.Annotations[i] != that1.Annotations[i] {
			return false
		}
	}
	if !this.Linux.Equal(that1.Linux) {
		return false
	}
	if !this.Solaris.Equal(that1.Solaris) {
		return false
	}
	if !this.Windows.Equal(that1.Windows) {
		return false
	}
	return true
}
func (this *Process) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Process)
	if !ok {
		that2, ok := that.(Process)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Terminal != that1.Terminal {
		return false
	}
	if !this.ConsoleSize.Equal(that1.ConsoleSize) {
		return false
	}
	if !this.User.Equal(&that1.User) {
		return false
	}
	if len(this.Args) != len(that1.Args) {
		return false
	}
	for i := range this.Args {
		if this.Args[i] != that1.Args[i] {
			return false
		}
	}
	if len(this.Env) != len(that1.Env) {
		return false
	}
	for i := range this.Env {
		if this.Env[i] != that1.Env[i] {
			return false
		}
	}
	if this.Cwd != that1.Cwd {
		return false
	}
	if !this.Capabilities.Equal(that1.Capabilities) {
		return false
	}
	if len(this.Rlimits) != len(that1.Rlimits) {
		return false
	}
	for i := range this.Rlimits {
		if !this.Rlimits[i].Equal(&that1.Rlimits[i]) {
			return false
		}
	}
	if this.NoNewPrivileges != that1.NoNewPrivileges {
		return false
	}
	if this.ApparmorProfile != that1.ApparmorProfile {
		return false
	}
	if this.OOMScoreAdj != that1.OOMScoreAdj {
		return false
	}
	if this.SelinuxLabel != that1.SelinuxLabel {
		return false
	}
	return true
}
func (this *Box) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Box)
	if !ok {
		that2, ok := that.(Box)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Height != that1.Height {
		return false
	}
	if this.Width != that1.Width {
		return false
	}
	return true
}
func (this *User) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*User)
	if !ok {
		that2, ok := that.(User)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.UID != that1.UID {
		return false
	}
	if this.GID != that1.GID {
		return false
	}
	if len(this.AdditionalGids) != len(that1.AdditionalGids) {
		return false
	}
	for i := range this.AdditionalGids {
		if this.AdditionalGids[i] != that1.AdditionalGids[i] {
			return false
		}
	}
	if this.Username != that1.Username {
		return false
	}
	return true
}
func (this *LinuxCapabilities) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LinuxCapabilities)
	if !ok {
		that2, ok := that.(LinuxCapabilities)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Bounding) != len(that1.Bounding) {
		return false
	}
	for i := range this.Bounding {
		if this.Bounding[i] != that1.Bounding[i] {
			return false
		}
	}
	if len(this.Effective) != len(that1.Effective) {
		return false
	}
	for i := range this.Effective {
		if this.Effective[i] != that1.Effective[i] {
			return false
		}
	}
	if len(this.Inheritable) != len(that1.Inheritable) {
		return false
	}
	for i := range this.Inheritable {
		if this.Inheritable[i] != that1.Inheritable[i] {
			return false
		}
	}
	if len(this.Permitted) != len(that1.Permitted) {
		return false
	}
	for i := range this.Permitted {
		if this.Permitted[i] != that1.Permitted[i] {
			return false
		}
	}
	if len(this.Ambient) != len(that1.Ambient) {
		return false
	}
	for i := range this.Ambient {
		if this.Ambient[i] != that1.Ambient[i] {
			return false
		}
	}
	return true
}
func (this *POSIXRlimit) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*POSIXRlimit)
	if !ok {
		that2, ok := that.(POSIXRlimit)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Hard != that1.Hard {
		return false
	}
	if this.Soft != that1.Soft {
		return false
	}
	return true
}
func (this *Mount) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Mount)
	if !ok {
		that2, ok := that.(Mount)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Destination != that1.Destination {
		return false
	}
	if this.Source != that1.Source {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if len(this.Options) != len(that1.Options) {
		return false
	}
	for i := range this.Options {
		if this.Options[i] != that1.Options[i] {
			return false
		}
	}
	return true
}
func (this *Root) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Root)
	if !ok {
		that2, ok := that.(Root)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Path != that1.Path {
		return false
	}
	if this.Readonly != that1.Readonly {
		return false
	}
	return true
}
func (this *Hooks) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Hooks)
	if !ok {
		that2, ok := that.(Hooks)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Prestart) != len(that1.Prestart) {
		return false
	}
	for i := range this.Prestart {
		if !this.Prestart[i].Equal(&that1.Prestart[i]) {
			return false
		}
	}
	if len(this.Poststart) != len(that1.Poststart) {
		return false
	}
	for i := range this.Poststart {
		if !this.Poststart[i].Equal(&that1.Poststart[i]) {
			return false
		}
	}
	if len(this.Poststop) != len(that1.Poststop) {
		return false
	}
	for i := range this.Poststop {
		if !this.Poststop[i].Equal(&that1.Poststop[i]) {
			return false
		}
	}
	return true
}
func (this *Hook) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Hook)
	if !ok {
		that2, ok := that.(Hook)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Path != that1.Path {
		return false
	}
	if len(this.Args) != len(that1.Args) {
		return false
	}
	for i := range this.Args {
		if this.Args[i] != that1.Args[i] {
			return false
		}
	}
	if len(this.Env) != len(that1.Env) {
		return false
	}
	for i := range this.Env {
		if this.Env[i] != that1.Env[i] {
			return false
		}
	}
	if this.Timeout != that1.Timeout {
		return false
	}
	return true
}
func (this *Linux) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Linux)
	if !ok {
		that2, ok := that.(Linux)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.UIDMappings) != len(that1.UIDMappings) {
		return false
	}
	for i := range this.UIDMappings {
		if !this.UIDMappings[i].Equal(&that1.UIDMappings[i]) {
			return false
		}
	}
	if len(this.GIDMappings) != len(that1.GIDMappings) {
		return false
	}
	for i := range this.GIDMappings {
		if !this.GIDMappings[i].Equal(&that1.GIDMappings[i]) {
			return false
		}
	}
	if len(this.Sysctl) != len(that1.Sysctl) {
		return false
	}
	for i := range this.Sysctl {
		if this.Sysctl[i] != that1.Sysctl[i] {
			return false
		}
	}
	if !this.Resources.Equal(that1.Resources) {
		return false
	}
	if this.CgroupsPath != that1.CgroupsPath {
		return false
	}
	if len(this.Namespaces) != len(that1.Namespaces) {
		return false
	}
	for i := range this.Namespaces {
		if !this.Namespaces[i].Equal(&that1.Namespaces[i]) {
			return false
		}
	}
	if len(this.Devices) != len(that1.Devices) {
		return false
	}
	for i := range this.Devices {
		if !this.Devices[i].Equal(&that1.Devices[i]) {
			return false
		}
	}
	if !this.Seccomp.Equal(that1.Seccomp) {
		return false
	}
	if this.RootfsPropagation != that1.RootfsPropagation {
		return false
	}
	if len(this.MaskedPaths) != len(that1.MaskedPaths) {
		return false
	}
	for i := range this.MaskedPaths {
		if this.MaskedPaths[i] != that1.MaskedPaths[i] {
			return false
		}
	}
	if len(this.ReadonlyPaths) != len(that1.ReadonlyPaths) {
		return false
	}
	for i := range this.ReadonlyPaths {
		if this.ReadonlyPaths[i] != that1.ReadonlyPaths[i] {
			return false
		}
	}
	if this.MountLabel != that1.MountLabel {
		return false
	}
	if !this.IntelRdt.Equal(that1.IntelRdt) {
		return false
	}
	return true
}
func (this *Windows) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Windows)
	if !ok {
		that2, ok := that.(Windows)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Dummy != that1.Dummy {
		return false
	}
	return true
}
func (this *Solaris) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Solaris)
	if !ok {
		that2, ok := that.(Solaris)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Dummy != that1.Dummy {
		return false
	}
	return true
}
func (this *LinuxIDMapping) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LinuxIDMapping)
	if !ok {
		that2, ok := that.(LinuxIDMapping)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.HostID != that1.HostID {
		return false
	}
	if this.ContainerID != that1.ContainerID {
		return false
	}
	if this.Size_ != that1.Size_ {
		return false
	}
	return true
}
func (this *LinuxNamespace) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LinuxNamespace)
	if !ok {
		that2, ok := that.(LinuxNamespace)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Path != that1.Path {
		return false
	}
	return true
}
func (this *LinuxDevice) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LinuxDevice)
	if !ok {
		that2, ok := that.(LinuxDevice)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Path != that1.Path {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Major != that1.Major {
		return false
	}
	if this.Minor != that1.Minor {
		return false
	}
	if this.FileMode != that1.FileMode {
		return false
	}
	if this.UID != that1.UID {
		return false
	}
	if this.GID != that1.GID {
		return false
	}
	return true
}
func (this *LinuxResources) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LinuxResources)
	if !ok {
		that2, ok := that.(LinuxResources)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Devices) != len(that1.Devices) {
		return false
	}
	for i := range this.Devices {
		if !this.Devices[i].Equal(&that1.Devices[i]) {
			return false
		}
	}
	if !this.Memory.Equal(that1.Memory) {
		return false
	}
	if !this.CPU.Equal(that1.CPU) {
		return false
	}
	if !this.Pids.Equal(that1.Pids) {
		return false
	}
	if !this.BlockIO.Equal(that1.BlockIO) {
		return false
	}
	if len(this.HugepageLimits) != len(that1.HugepageLimits) {
		return false
	}
	for i := range this.HugepageLimits {
		if !this.HugepageLimits[i].Equal(&that1.HugepageLimits[i]) {
			return false
		}
	}
	if !this.Network.Equal(that1.Network) {
		return false
	}
	return true
}
func (this *LinuxMemory) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LinuxMemory)
	if !ok {
		that2, ok := that.(LinuxMemory)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Limit != that1.Limit {
		return false
	}
	if this.Reservation != that1.Reservation {
		return false
	}
	if this.Swap != that1.Swap {
		return false
	}
	if this.Kernel != that1.Kernel {
		return false
	}
	if this.KernelTCP != that1.KernelTCP {
		return false
	}
	if this.Swappiness != that1.Swappiness {
		return false
	}
	if this.DisableOOMKiller != that1.DisableOOMKiller {
		return false
	}
	return true
}
func (this *LinuxCPU) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LinuxCPU)
	if !ok {
		that2, ok := that.(LinuxCPU)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Shares != that1.Shares {
		return false
	}
	if this.Quota != that1.Quota {
		return false
	}
	if this.Period != that1.Period {
		return false
	}
	if this.RealtimeRuntime != that1.RealtimeRuntime {
		return false
	}
	if this.RealtimePeriod != that1.RealtimePeriod {
		return false
	}
	if this.Cpus != that1.Cpus {
		return false
	}
	if this.Mems != that1.Mems {
		return false
	}
	return true
}
func (this *LinuxWeightDevice) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LinuxWeightDevice)
	if !ok {
		that2, ok := that.(LinuxWeightDevice)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Major != that1.Major {
		return false
	}
	if this.Minor != that1.Minor {
		return false
	}
	if this.Weight != that1.Weight {
		return false
	}
	if this.LeafWeight != that1.LeafWeight {
		return false
	}
	return true
}
func (this *LinuxThrottleDevice) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LinuxThrottleDevice)
	if !ok {
		that2, ok := that.(LinuxThrottleDevice)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Major != that1.Major {
		return false
	}
	if this.Minor != that1.Minor {
		return false
	}
	if this.Rate != that1.Rate {
		return false
	}
	return true
}
func (this *LinuxBlockIO) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LinuxBlockIO)
	if !ok {
		that2, ok := that.(LinuxBlockIO)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Weight != that1.Weight {
		return false
	}
	if this.LeafWeight != that1.LeafWeight {
		return false
	}
	if len(this.WeightDevice) != len(that1.WeightDevice) {
		return false
	}
	for i := range this.WeightDevice {
		if !this.WeightDevice[i].Equal(&that1.WeightDevice[i]) {
			return false
		}
	}
	if len(this.ThrottleReadBpsDevice) != len(that1.ThrottleReadBpsDevice) {
		return false
	}
	for i := range this.ThrottleReadBpsDevice {
		if !this.ThrottleReadBpsDevice[i].Equal(&that1.ThrottleReadBpsDevice[i]) {
			return false
		}
	}
	if len(this.ThrottleWriteBpsDevice) != len(that1.ThrottleWriteBpsDevice) {
		return false
	}
	for i := range this.ThrottleWriteBpsDevice {
		if !this.ThrottleWriteBpsDevice[i].Equal(&that1.ThrottleWriteBpsDevice[i]) {
			return false
		}
	}
	if len(this.ThrottleReadIOPSDevice) != len(that1.ThrottleReadIOPSDevice) {
		return false
	}
	for i := range this.ThrottleReadIOPSDevice {
		if !this.ThrottleReadIOPSDevice[i].Equal(&that1.ThrottleReadIOPSDevice[i]) {
			return false
		}
	}
	if len(this.ThrottleWriteIOPSDevice) != len(that1.ThrottleWriteIOPSDevice) {
		return false
	}
	for i := range this.ThrottleWriteIOPSDevice {
		if !this.ThrottleWriteIOPSDevice[i].Equal(&that1.ThrottleWriteIOPSDevice[i]) {
			return false
		}
	}
	return true
}
func (this *LinuxPids) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LinuxPids)
	if !ok {
		that2, ok := that.(LinuxPids)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Limit != that1.Limit {
		return false
	}
	return true
}
func (this *LinuxDeviceCgroup) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LinuxDeviceCgroup)
	if !ok {
		that2, ok := that.(LinuxDeviceCgroup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Allow != that1.Allow {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Major != that1.Major {
		return false
	}
	if this.Minor != that1.Minor {
		return false
	}
	if this.Access != that1.Access {
		return false
	}
	return true
}
func (this *LinuxNetwork) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LinuxNetwork)
	if !ok {
		that2, ok := that.(LinuxNetwork)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ClassID != that1.ClassID {
		return false
	}
	if len(this.Priorities) != len(that1.Priorities) {
		return false
	}
	for i := range this.Priorities {
		if !this.Priorities[i].Equal(&that1.Priorities[i]) {
			return false
		}
	}
	return true
}
func (this *LinuxHugepageLimit) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LinuxHugepageLimit)
	if !ok {
		that2, ok := that.(LinuxHugepageLimit)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Pagesize != that1.Pagesize {
		return false
	}
	if this.Limit != that1.Limit {
		return false
	}
	return true
}
func (this *LinuxInterfacePriority) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LinuxInterfacePriority)
	if !ok {
		that2, ok := that.(LinuxInterfacePriority)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Priority != that1.Priority {
		return false
	}
	return true
}
func (this *LinuxSeccomp) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LinuxSeccomp)
	if !ok {
		that2, ok := that.(LinuxSeccomp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.DefaultAction != that1.DefaultAction {
		return false
	}
	if len(this.Architectures) != len(that1.Architectures) {
		return false
	}
	for i := range this.Architectures {
		if this.Architectures[i] != that1.Architectures[i] {
			return false
		}
	}
	if len(this.Syscalls) != len(that1.Syscalls) {
		return false
	}
	for i := range this.Syscalls {
		if !this.Syscalls[i].Equal(&that1.Syscalls[i]) {
			return false
		}
	}
	return true
}
func (this *LinuxSeccompArg) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LinuxSeccompArg)
	if !ok {
		that2, ok := that.(LinuxSeccompArg)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Index != that1.Index {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	if this.ValueTwo != that1.ValueTwo {
		return false
	}
	if this.Op != that1.Op {
		return false
	}
	return true
}
func (this *LinuxSyscall) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LinuxSyscall)
	if !ok {
		that2, ok := that.(LinuxSyscall)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Names) != len(that1.Names) {
		return false
	}
	for i := range this.Names {
		if this.Names[i] != that1.Names[i] {
			return false
		}
	}
	if this.Action != that1.Action {
		return false
	}
	if len(this.Args) != len(that1.Args) {
		return false
	}
	for i := range this.Args {
		if !this.Args[i].Equal(&that1.Args[i]) {
			return false
		}
	}
	return true
}
func (this *LinuxIntelRdt) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LinuxIntelRdt)
	if !ok {
		that2, ok := that.(LinuxIntelRdt)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.L3CacheSchema != that1.L3CacheSchema {
		return false
	}
	return true
}
func NewPopulatedSpec(r randyOci, easy bool) *Spec {
	this := &Spec{}
	this.Version = string(randStringOci(r))
	if r.Intn(10) != 0 {
		this.Process = NewPopulatedProcess(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Root = NewPopulatedRoot(r, easy)
	}
	this.Hostname = string(randStringOci(r))
	if r.Intn(10) != 0 {
		v1 := r.Intn(5)
		this.Mounts = make([]Mount, v1)
		for i := 0; i < v1; i++ {
			v2 := NewPopulatedMount(r, easy)
			this.Mounts[i] = *v2
		}
	}
	if r.Intn(10) != 0 {
		this.Hooks = NewPopulatedHooks(r, easy)
	}
	if r.Intn(10) != 0 {
		v3 := r.Intn(10)
		this.Annotations = make(map[string]string)
		for i := 0; i < v3; i++ {
			this.Annotations[randStringOci(r)] = randStringOci(r)
		}
	}
	if r.Intn(10) != 0 {
		this.Linux = NewPopulatedLinux(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Solaris = NewPopulatedSolaris(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Windows = NewPopulatedWindows(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedProcess(r randyOci, easy bool) *Process {
	this := &Process{}
	this.Terminal = bool(bool(r.Intn(2) == 0))
	if r.Intn(10) != 0 {
		this.ConsoleSize = NewPopulatedBox(r, easy)
	}
	v4 := NewPopulatedUser(r, easy)
	this.User = *v4
	v5 := r.Intn(10)
	this.Args = make([]string, v5)
	for i := 0; i < v5; i++ {
		this.Args[i] = string(randStringOci(r))
	}
	v6 := r.Intn(10)
	this.Env = make([]string, v6)
	for i := 0; i < v6; i++ {
		this.Env[i] = string(randStringOci(r))
	}
	this.Cwd = string(randStringOci(r))
	if r.Intn(10) != 0 {
		this.Capabilities = NewPopulatedLinuxCapabilities(r, easy)
	}
	if r.Intn(10) != 0 {
		v7 := r.Intn(5)
		this.Rlimits = make([]POSIXRlimit, v7)
		for i := 0; i < v7; i++ {
			v8 := NewPopulatedPOSIXRlimit(r, easy)
			this.Rlimits[i] = *v8
		}
	}
	this.NoNewPrivileges = bool(bool(r.Intn(2) == 0))
	this.ApparmorProfile = string(randStringOci(r))
	this.OOMScoreAdj = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.OOMScoreAdj *= -1
	}
	this.SelinuxLabel = string(randStringOci(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedBox(r randyOci, easy bool) *Box {
	this := &Box{}
	this.Height = uint32(r.Uint32())
	this.Width = uint32(r.Uint32())
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedUser(r randyOci, easy bool) *User {
	this := &User{}
	this.UID = uint32(r.Uint32())
	this.GID = uint32(r.Uint32())
	v9 := r.Intn(10)
	this.AdditionalGids = make([]uint32, v9)
	for i := 0; i < v9; i++ {
		this.AdditionalGids[i] = uint32(r.Uint32())
	}
	this.Username = string(randStringOci(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLinuxCapabilities(r randyOci, easy bool) *LinuxCapabilities {
	this := &LinuxCapabilities{}
	v10 := r.Intn(10)
	this.Bounding = make([]string, v10)
	for i := 0; i < v10; i++ {
		this.Bounding[i] = string(randStringOci(r))
	}
	v11 := r.Intn(10)
	this.Effective = make([]string, v11)
	for i := 0; i < v11; i++ {
		this.Effective[i] = string(randStringOci(r))
	}
	v12 := r.Intn(10)
	this.Inheritable = make([]string, v12)
	for i := 0; i < v12; i++ {
		this.Inheritable[i] = string(randStringOci(r))
	}
	v13 := r.Intn(10)
	this.Permitted = make([]string, v13)
	for i := 0; i < v13; i++ {
		this.Permitted[i] = string(randStringOci(r))
	}
	v14 := r.Intn(10)
	this.Ambient = make([]string, v14)
	for i := 0; i < v14; i++ {
		this.Ambient[i] = string(randStringOci(r))
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedPOSIXRlimit(r randyOci, easy bool) *POSIXRlimit {
	this := &POSIXRlimit{}
	this.Type = string(randStringOci(r))
	this.Hard = uint64(uint64(r.Uint32()))
	this.Soft = uint64(uint64(r.Uint32()))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedMount(r randyOci, easy bool) *Mount {
	this := &Mount{}
	this.Destination = string(randStringOci(r))
	this.Source = string(randStringOci(r))
	this.Type = string(randStringOci(r))
	v15 := r.Intn(10)
	this.Options = make([]string, v15)
	for i := 0; i < v15; i++ {
		this.Options[i] = string(randStringOci(r))
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedRoot(r randyOci, easy bool) *Root {
	this := &Root{}
	this.Path = string(randStringOci(r))
	this.Readonly = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedHooks(r randyOci, easy bool) *Hooks {
	this := &Hooks{}
	if r.Intn(10) != 0 {
		v16 := r.Intn(5)
		this.Prestart = make([]Hook, v16)
		for i := 0; i < v16; i++ {
			v17 := NewPopulatedHook(r, easy)
			this.Prestart[i] = *v17
		}
	}
	if r.Intn(10) != 0 {
		v18 := r.Intn(5)
		this.Poststart = make([]Hook, v18)
		for i := 0; i < v18; i++ {
			v19 := NewPopulatedHook(r, easy)
			this.Poststart[i] = *v19
		}
	}
	if r.Intn(10) != 0 {
		v20 := r.Intn(5)
		this.Poststop = make([]Hook, v20)
		for i := 0; i < v20; i++ {
			v21 := NewPopulatedHook(r, easy)
			this.Poststop[i] = *v21
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedHook(r randyOci, easy bool) *Hook {
	this := &Hook{}
	this.Path = string(randStringOci(r))
	v22 := r.Intn(10)
	this.Args = make([]string, v22)
	for i := 0; i < v22; i++ {
		this.Args[i] = string(randStringOci(r))
	}
	v23 := r.Intn(10)
	this.Env = make([]string, v23)
	for i := 0; i < v23; i++ {
		this.Env[i] = string(randStringOci(r))
	}
	this.Timeout = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Timeout *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLinux(r randyOci, easy bool) *Linux {
	this := &Linux{}
	if r.Intn(10) != 0 {
		v24 := r.Intn(5)
		this.UIDMappings = make([]LinuxIDMapping, v24)
		for i := 0; i < v24; i++ {
			v25 := NewPopulatedLinuxIDMapping(r, easy)
			this.UIDMappings[i] = *v25
		}
	}
	if r.Intn(10) != 0 {
		v26 := r.Intn(5)
		this.GIDMappings = make([]LinuxIDMapping, v26)
		for i := 0; i < v26; i++ {
			v27 := NewPopulatedLinuxIDMapping(r, easy)
			this.GIDMappings[i] = *v27
		}
	}
	if r.Intn(10) != 0 {
		v28 := r.Intn(10)
		this.Sysctl = make(map[string]string)
		for i := 0; i < v28; i++ {
			this.Sysctl[randStringOci(r)] = randStringOci(r)
		}
	}
	if r.Intn(10) != 0 {
		this.Resources = NewPopulatedLinuxResources(r, easy)
	}
	this.CgroupsPath = string(randStringOci(r))
	if r.Intn(10) != 0 {
		v29 := r.Intn(5)
		this.Namespaces = make([]LinuxNamespace, v29)
		for i := 0; i < v29; i++ {
			v30 := NewPopulatedLinuxNamespace(r, easy)
			this.Namespaces[i] = *v30
		}
	}
	if r.Intn(10) != 0 {
		v31 := r.Intn(5)
		this.Devices = make([]LinuxDevice, v31)
		for i := 0; i < v31; i++ {
			v32 := NewPopulatedLinuxDevice(r, easy)
			this.Devices[i] = *v32
		}
	}
	if r.Intn(10) != 0 {
		this.Seccomp = NewPopulatedLinuxSeccomp(r, easy)
	}
	this.RootfsPropagation = string(randStringOci(r))
	v33 := r.Intn(10)
	this.MaskedPaths = make([]string, v33)
	for i := 0; i < v33; i++ {
		this.MaskedPaths[i] = string(randStringOci(r))
	}
	v34 := r.Intn(10)
	this.ReadonlyPaths = make([]string, v34)
	for i := 0; i < v34; i++ {
		this.ReadonlyPaths[i] = string(randStringOci(r))
	}
	this.MountLabel = string(randStringOci(r))
	if r.Intn(10) != 0 {
		this.IntelRdt = NewPopulatedLinuxIntelRdt(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedWindows(r randyOci, easy bool) *Windows {
	this := &Windows{}
	this.Dummy = string(randStringOci(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedSolaris(r randyOci, easy bool) *Solaris {
	this := &Solaris{}
	this.Dummy = string(randStringOci(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLinuxIDMapping(r randyOci, easy bool) *LinuxIDMapping {
	this := &LinuxIDMapping{}
	this.HostID = uint32(r.Uint32())
	this.ContainerID = uint32(r.Uint32())
	this.Size_ = uint32(r.Uint32())
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLinuxNamespace(r randyOci, easy bool) *LinuxNamespace {
	this := &LinuxNamespace{}
	this.Type = string(randStringOci(r))
	this.Path = string(randStringOci(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLinuxDevice(r randyOci, easy bool) *LinuxDevice {
	this := &LinuxDevice{}
	this.Path = string(randStringOci(r))
	this.Type = string(randStringOci(r))
	this.Major = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Major *= -1
	}
	this.Minor = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Minor *= -1
	}
	this.FileMode = uint32(r.Uint32())
	this.UID = uint32(r.Uint32())
	this.GID = uint32(r.Uint32())
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLinuxResources(r randyOci, easy bool) *LinuxResources {
	this := &LinuxResources{}
	if r.Intn(10) != 0 {
		v35 := r.Intn(5)
		this.Devices = make([]LinuxDeviceCgroup, v35)
		for i := 0; i < v35; i++ {
			v36 := NewPopulatedLinuxDeviceCgroup(r, easy)
			this.Devices[i] = *v36
		}
	}
	if r.Intn(10) != 0 {
		this.Memory = NewPopulatedLinuxMemory(r, easy)
	}
	if r.Intn(10) != 0 {
		this.CPU = NewPopulatedLinuxCPU(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Pids = NewPopulatedLinuxPids(r, easy)
	}
	if r.Intn(10) != 0 {
		this.BlockIO = NewPopulatedLinuxBlockIO(r, easy)
	}
	if r.Intn(10) != 0 {
		v37 := r.Intn(5)
		this.HugepageLimits = make([]LinuxHugepageLimit, v37)
		for i := 0; i < v37; i++ {
			v38 := NewPopulatedLinuxHugepageLimit(r, easy)
			this.HugepageLimits[i] = *v38
		}
	}
	if r.Intn(10) != 0 {
		this.Network = NewPopulatedLinuxNetwork(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLinuxMemory(r randyOci, easy bool) *LinuxMemory {
	this := &LinuxMemory{}
	this.Limit = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Limit *= -1
	}
	this.Reservation = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Reservation *= -1
	}
	this.Swap = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Swap *= -1
	}
	this.Kernel = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Kernel *= -1
	}
	this.KernelTCP = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.KernelTCP *= -1
	}
	this.Swappiness = uint64(uint64(r.Uint32()))
	this.DisableOOMKiller = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLinuxCPU(r randyOci, easy bool) *LinuxCPU {
	this := &LinuxCPU{}
	this.Shares = uint64(uint64(r.Uint32()))
	this.Quota = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Quota *= -1
	}
	this.Period = uint64(uint64(r.Uint32()))
	this.RealtimeRuntime = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.RealtimeRuntime *= -1
	}
	this.RealtimePeriod = uint64(uint64(r.Uint32()))
	this.Cpus = string(randStringOci(r))
	this.Mems = string(randStringOci(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLinuxWeightDevice(r randyOci, easy bool) *LinuxWeightDevice {
	this := &LinuxWeightDevice{}
	this.Major = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Major *= -1
	}
	this.Minor = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Minor *= -1
	}
	this.Weight = uint32(r.Uint32())
	this.LeafWeight = uint32(r.Uint32())
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLinuxThrottleDevice(r randyOci, easy bool) *LinuxThrottleDevice {
	this := &LinuxThrottleDevice{}
	this.Major = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Major *= -1
	}
	this.Minor = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Minor *= -1
	}
	this.Rate = uint64(uint64(r.Uint32()))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLinuxBlockIO(r randyOci, easy bool) *LinuxBlockIO {
	this := &LinuxBlockIO{}
	this.Weight = uint32(r.Uint32())
	this.LeafWeight = uint32(r.Uint32())
	if r.Intn(10) != 0 {
		v39 := r.Intn(5)
		this.WeightDevice = make([]LinuxWeightDevice, v39)
		for i := 0; i < v39; i++ {
			v40 := NewPopulatedLinuxWeightDevice(r, easy)
			this.WeightDevice[i] = *v40
		}
	}
	if r.Intn(10) != 0 {
		v41 := r.Intn(5)
		this.ThrottleReadBpsDevice = make([]LinuxThrottleDevice, v41)
		for i := 0; i < v41; i++ {
			v42 := NewPopulatedLinuxThrottleDevice(r, easy)
			this.ThrottleReadBpsDevice[i] = *v42
		}
	}
	if r.Intn(10) != 0 {
		v43 := r.Intn(5)
		this.ThrottleWriteBpsDevice = make([]LinuxThrottleDevice, v43)
		for i := 0; i < v43; i++ {
			v44 := NewPopulatedLinuxThrottleDevice(r, easy)
			this.ThrottleWriteBpsDevice[i] = *v44
		}
	}
	if r.Intn(10) != 0 {
		v45 := r.Intn(5)
		this.ThrottleReadIOPSDevice = make([]LinuxThrottleDevice, v45)
		for i := 0; i < v45; i++ {
			v46 := NewPopulatedLinuxThrottleDevice(r, easy)
			this.ThrottleReadIOPSDevice[i] = *v46
		}
	}
	if r.Intn(10) != 0 {
		v47 := r.Intn(5)
		this.ThrottleWriteIOPSDevice = make([]LinuxThrottleDevice, v47)
		for i := 0; i < v47; i++ {
			v48 := NewPopulatedLinuxThrottleDevice(r, easy)
			this.ThrottleWriteIOPSDevice[i] = *v48
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLinuxPids(r randyOci, easy bool) *LinuxPids {
	this := &LinuxPids{}
	this.Limit = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Limit *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLinuxDeviceCgroup(r randyOci, easy bool) *LinuxDeviceCgroup {
	this := &LinuxDeviceCgroup{}
	this.Allow = bool(bool(r.Intn(2) == 0))
	this.Type = string(randStringOci(r))
	this.Major = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Major *= -1
	}
	this.Minor = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Minor *= -1
	}
	this.Access = string(randStringOci(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLinuxNetwork(r randyOci, easy bool) *LinuxNetwork {
	this := &LinuxNetwork{}
	this.ClassID = uint32(r.Uint32())
	if r.Intn(10) != 0 {
		v49 := r.Intn(5)
		this.Priorities = make([]LinuxInterfacePriority, v49)
		for i := 0; i < v49; i++ {
			v50 := NewPopulatedLinuxInterfacePriority(r, easy)
			this.Priorities[i] = *v50
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLinuxHugepageLimit(r randyOci, easy bool) *LinuxHugepageLimit {
	this := &LinuxHugepageLimit{}
	this.Pagesize = string(randStringOci(r))
	this.Limit = uint64(uint64(r.Uint32()))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLinuxInterfacePriority(r randyOci, easy bool) *LinuxInterfacePriority {
	this := &LinuxInterfacePriority{}
	this.Name = string(randStringOci(r))
	this.Priority = uint32(r.Uint32())
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLinuxSeccomp(r randyOci, easy bool) *LinuxSeccomp {
	this := &LinuxSeccomp{}
	this.DefaultAction = string(randStringOci(r))
	v51 := r.Intn(10)
	this.Architectures = make([]string, v51)
	for i := 0; i < v51; i++ {
		this.Architectures[i] = string(randStringOci(r))
	}
	if r.Intn(10) != 0 {
		v52 := r.Intn(5)
		this.Syscalls = make([]LinuxSyscall, v52)
		for i := 0; i < v52; i++ {
			v53 := NewPopulatedLinuxSyscall(r, easy)
			this.Syscalls[i] = *v53
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLinuxSeccompArg(r randyOci, easy bool) *LinuxSeccompArg {
	this := &LinuxSeccompArg{}
	this.Index = uint64(uint64(r.Uint32()))
	this.Value = uint64(uint64(r.Uint32()))
	this.ValueTwo = uint64(uint64(r.Uint32()))
	this.Op = string(randStringOci(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLinuxSyscall(r randyOci, easy bool) *LinuxSyscall {
	this := &LinuxSyscall{}
	v54 := r.Intn(10)
	this.Names = make([]string, v54)
	for i := 0; i < v54; i++ {
		this.Names[i] = string(randStringOci(r))
	}
	this.Action = string(randStringOci(r))
	if r.Intn(10) != 0 {
		v55 := r.Intn(5)
		this.Args = make([]LinuxSeccompArg, v55)
		for i := 0; i < v55; i++ {
			v56 := NewPopulatedLinuxSeccompArg(r, easy)
			this.Args[i] = *v56
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLinuxIntelRdt(r randyOci, easy bool) *LinuxIntelRdt {
	this := &LinuxIntelRdt{}
	this.L3CacheSchema = string(randStringOci(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyOci interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneOci(r randyOci) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringOci(r randyOci) string {
	v57 := r.Intn(100)
	tmps := make([]rune, v57)
	for i := 0; i < v57; i++ {
		tmps[i] = randUTF8RuneOci(r)
	}
	return string(tmps)
}
func randUnrecognizedOci(r randyOci, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldOci(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldOci(dAtA []byte, r randyOci, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateOci(dAtA, uint64(key))
		v58 := r.Int63()
		if r.Intn(2) == 0 {
			v58 *= -1
		}
		dAtA = encodeVarintPopulateOci(dAtA, uint64(v58))
	case 1:
		dAtA = encodeVarintPopulateOci(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateOci(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateOci(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateOci(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateOci(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}

func init() { proto.RegisterFile("oci.proto", fileDescriptorOci) }

var fileDescriptorOci = []byte{
	// 2021 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x18, 0x4d, 0x6f, 0x23, 0x49,
	0x15, 0xbb, 0x1d, 0xc7, 0x2e, 0x4f, 0xe6, 0xa3, 0x76, 0x76, 0xb6, 0x09, 0xab, 0x6c, 0xb6, 0x19,
	0x41, 0x80, 0x21, 0x11, 0x33, 0x7c, 0x2c, 0xcb, 0x87, 0xe4, 0x24, 0x33, 0x13, 0x6b, 0x93, 0x89,
	0x29, 0x27, 0x1b, 0xe0, 0x80, 0xd4, 0x69, 0x57, 0xec, 0xda, 0xb4, 0xbb, 0x5a, 0xd5, 0xe5, 0x64,
	0xc2, 0x8d, 0x7f, 0x80, 0xc4, 0x2f, 0xe0, 0x04, 0xfc, 0x03, 0xc4, 0x89, 0x1b, 0x88, 0xbf, 0x80,
	0x04, 0x62, 0xee, 0xdc, 0x39, 0xa2, 0xf7, 0xea, 0x75, 0xbb, 0xec, 0x24, 0xb0, 0x0b, 0x27, 0xd7,
	0xfb, 0xac, 0x7a, 0xdf, 0xaf, 0xcd, 0xda, 0x3a, 0x51, 0x9b, 0xb9, 0xd1, 0x56, 0xf3, 0xc6, 0xc8,
	0xe4, 0xc9, 0xea, 0xd7, 0x47, 0xca, 0x8e, 0xa7, 0xa7, 0x9b, 0x89, 0x9e, 0x6c, 0x8d, 0xf4, 0x48,
	0x6f, 0x21, 0xf1, 0x74, 0x7a, 0x86, 0x10, 0x02, 0x78, 0x72, 0x42, 0xab, 0x6b, 0x23, 0xad, 0x47,
	0xa9, 0x9c, 0x71, 0x5d, 0x9a, 0x38, 0xcf, 0xa5, 0x29, 0x1c, 0x3d, 0xfa, 0x53, 0xc0, 0x1a, 0x83,
	0x5c, 0x26, 0x3c, 0x64, 0xcb, 0x1f, 0x4b, 0x53, 0x28, 0x9d, 0x85, 0xb5, 0xf5, 0xda, 0x46, 0x5b,
	0x94, 0x20, 0xff, 0x32, 0x5b, 0xee, 0x1b, 0x9d, 0xc8, 0xa2, 0x08, 0xeb, 0xeb, 0xb5, 0x8d, 0xce,
	0xd3, 0x95, 0x4d, 0x78, 0xc9, 0x26, 0x21, 0x45, 0x49, 0xe5, 0x6b, 0xac, 0x21, 0xb4, 0xb6, 0x61,
	0x80, 0x5c, 0xcc, 0x71, 0x01, 0x46, 0x20, 0x9e, 0xaf, 0xb2, 0xd6, 0x9e, 0x2e, 0x6c, 0x16, 0x4f,
	0x64, 0xd8, 0xc0, 0x3b, 0x2a, 0x98, 0x7f, 0x85, 0x35, 0x0f, 0xf4, 0x34, 0xb3, 0x45, 0xb8, 0xb4,
	0x1e, 0x6c, 0x74, 0x9e, 0x76, 0x9c, 0x34, 0xe2, 0xb6, 0x1b, 0x7f, 0xfe, 0xdb, 0x7b, 0x9f, 0x13,
	0xc4, 0xc0, 0xdf, 0x67, 0x4b, 0x7b, 0x5a, 0x9f, 0x17, 0x61, 0x13, 0xef, 0x21, 0x4e, 0x44, 0x09,
	0x47, 0xe1, 0x3f, 0x60, 0x9d, 0x6e, 0x96, 0x69, 0x1b, 0x5b, 0xa5, 0xb3, 0x22, 0x5c, 0x46, 0x95,
	0x5f, 0x70, 0x8c, 0x60, 0xed, 0xa6, 0x47, 0x7d, 0x9e, 0x59, 0x73, 0x25, 0x7c, 0x7e, 0xb8, 0x61,
	0x5f, 0x65, 0xd3, 0xd7, 0x61, 0xcb, 0xbf, 0x01, 0x51, 0xc2, 0x51, 0xc0, 0x29, 0x03, 0x9d, 0xc6,
	0x46, 0x15, 0x61, 0xdb, 0x77, 0x0a, 0x21, 0x45, 0x49, 0x05, 0xc6, 0x13, 0x95, 0x0d, 0xf5, 0x65,
	0x11, 0x32, 0x9f, 0x91, 0x90, 0xa2, 0xa4, 0xae, 0xfe, 0x90, 0xdd, 0x5f, 0x7c, 0x15, 0xbf, 0xcf,
	0x82, 0x73, 0x79, 0x45, 0x01, 0x81, 0x23, 0x7f, 0xc8, 0x96, 0x2e, 0xe2, 0x74, 0x2a, 0x31, 0x14,
	0x6d, 0xe1, 0x80, 0x0f, 0xeb, 0x1f, 0xd4, 0xa2, 0x3f, 0x04, 0x55, 0x9c, 0xc0, 0xd3, 0x47, 0xd2,
	0x4c, 0x54, 0x16, 0xa7, 0x28, 0xdc, 0x12, 0x15, 0xcc, 0xbf, 0xc6, 0x3a, 0x3b, 0x3a, 0x2b, 0x74,
	0x2a, 0x07, 0xea, 0xe7, 0x92, 0x42, 0xda, 0x76, 0x8f, 0xda, 0xd6, 0xaf, 0x85, 0x4f, 0xe5, 0x8f,
	0x59, 0xe3, 0xb8, 0x90, 0x66, 0x3e, 0xa4, 0x80, 0xa1, 0x98, 0x20, 0x95, 0x73, 0xd6, 0xe8, 0x9a,
	0x51, 0x11, 0x36, 0xd6, 0x83, 0x8d, 0xb6, 0xc0, 0x33, 0x3c, 0xfd, 0x79, 0x76, 0x81, 0xd1, 0x6c,
	0x0b, 0x38, 0x02, 0x66, 0xe7, 0x72, 0x88, 0x51, 0x6b, 0x0b, 0x38, 0xf2, 0xef, 0xb1, 0x3b, 0x3b,
	0x71, 0x1e, 0x9f, 0xaa, 0x54, 0x59, 0x25, 0x21, 0x4e, 0x70, 0xcb, 0x3b, 0x9e, 0xbb, 0x7d, 0xb2,
	0x98, 0x63, 0xe6, 0xdf, 0x60, 0xcb, 0x22, 0x55, 0x13, 0x65, 0x8b, 0xb0, 0x85, 0xf1, 0x7d, 0x40,
	0x69, 0x79, 0x38, 0xe8, 0xfd, 0xd8, 0x51, 0xe8, 0x91, 0x25, 0x1f, 0xdf, 0x60, 0xf7, 0x5e, 0xe9,
	0x57, 0xf2, 0xb2, 0x6f, 0xd4, 0x85, 0x4a, 0xe5, 0x48, 0xba, 0xe0, 0xb5, 0xc4, 0x22, 0x1a, 0x38,
	0xbb, 0x79, 0x1e, 0x9b, 0x89, 0x36, 0x7d, 0xa3, 0xcf, 0x54, 0x2a, 0x31, 0x7a, 0x6d, 0xb1, 0x88,
	0xe6, 0xeb, 0xac, 0x73, 0x78, 0x78, 0x30, 0x48, 0xb4, 0x91, 0xdd, 0xe1, 0x27, 0x61, 0x67, 0xbd,
	0xb6, 0x11, 0x08, 0x1f, 0xc5, 0x23, 0x76, 0x67, 0x20, 0x53, 0xb0, 0x66, 0x3f, 0x3e, 0x95, 0x69,
	0x78, 0x07, 0x15, 0xcd, 0xe1, 0xa2, 0x67, 0x2c, 0xd8, 0xd6, 0xaf, 0xf9, 0x23, 0xd6, 0xdc, 0x93,
	0x6a, 0x34, 0xb6, 0x18, 0xb5, 0x15, 0x41, 0x10, 0x44, 0xfd, 0x44, 0x0d, 0xed, 0x18, 0xa3, 0xb5,
	0x22, 0x1c, 0x10, 0x65, 0x2e, 0x38, 0xe0, 0xd8, 0xe3, 0xde, 0x2e, 0x89, 0xc0, 0x11, 0x30, 0x2f,
	0x7b, 0xbb, 0xc4, 0x0d, 0x47, 0xfe, 0x25, 0x76, 0xb7, 0x3b, 0x1c, 0x2a, 0xc8, 0xad, 0x38, 0x7d,
	0xa9, 0x86, 0x45, 0x18, 0xac, 0x07, 0x1b, 0x2b, 0x62, 0x01, 0x0b, 0x99, 0x03, 0x3a, 0xfd, 0x1a,
	0x2d, 0xe1, 0xe8, 0x37, 0x35, 0xf6, 0xe0, 0x5a, 0x54, 0x40, 0x62, 0x5b, 0x4f, 0xb3, 0xa1, 0xca,
	0x46, 0x61, 0x0d, 0xa3, 0x5d, 0xc1, 0xfc, 0x5d, 0xd6, 0x7e, 0x7e, 0x76, 0x26, 0x13, 0xab, 0x2e,
	0x20, 0xd3, 0x80, 0x38, 0x43, 0x80, 0xeb, 0x7a, 0xd9, 0x58, 0x1a, 0x65, 0xe3, 0xd3, 0x54, 0xe2,
	0x83, 0xda, 0xc2, 0x47, 0x81, 0x7c, 0x1f, 0xf2, 0xd6, 0x5a, 0x39, 0xa4, 0xec, 0x9a, 0x21, 0xa0,
	0x65, 0x75, 0x27, 0xa7, 0x4a, 0x66, 0x96, 0xd2, 0xac, 0x04, 0xa3, 0x1e, 0xeb, 0x78, 0x69, 0x00,
	0xf9, 0x79, 0x74, 0x95, 0x4b, 0xaa, 0x23, 0x3c, 0x03, 0x6e, 0x2f, 0x36, 0x43, 0xf4, 0x51, 0x43,
	0xe0, 0x19, 0x70, 0x03, 0x7d, 0xe6, 0x1a, 0x58, 0x43, 0xe0, 0x39, 0xd2, 0x6c, 0x09, 0xfb, 0x0e,
	0xbc, 0x76, 0x28, 0x0b, 0xab, 0x32, 0x2c, 0x50, 0xd2, 0xe5, 0xa3, 0x20, 0x7a, 0x85, 0x9e, 0x9a,
	0xa4, 0x2c, 0x4e, 0x82, 0x40, 0xad, 0x85, 0xeb, 0x03, 0x77, 0x3d, 0x9c, 0xe1, 0xed, 0x3a, 0x77,
	0xdd, 0xc9, 0xd9, 0x55, 0x82, 0xd1, 0xb7, 0x5d, 0x17, 0x05, 0xa9, 0x7e, 0x6c, 0xc7, 0xe5, 0xa3,
	0xe1, 0x0c, 0xbe, 0x16, 0x32, 0x1e, 0xea, 0x2c, 0xbd, 0xc2, 0x3b, 0x5a, 0xa2, 0x82, 0xa3, 0x5f,
	0xd5, 0xa8, 0x2f, 0xf2, 0x27, 0xac, 0xd5, 0x37, 0xb2, 0xb0, 0xb1, 0xb1, 0x18, 0x91, 0xaa, 0x70,
	0x81, 0x4c, 0x35, 0x51, 0x71, 0xf0, 0x4d, 0xd6, 0xee, 0xeb, 0xc2, 0x3a, 0xf6, 0xfa, 0x2d, 0xec,
	0x33, 0x16, 0xd4, 0x8e, 0x80, 0xce, 0x31, 0x64, 0x37, 0x6b, 0x27, 0x8e, 0xe8, 0xa7, 0xac, 0x01,
	0xf8, 0x1b, 0xad, 0x29, 0xdb, 0x46, 0xfd, 0x7a, 0xdb, 0x08, 0x66, 0x6d, 0x23, 0x64, 0xcb, 0x47,
	0x6a, 0x22, 0xf5, 0xd4, 0x62, 0x42, 0x06, 0xa2, 0x04, 0xa3, 0xdf, 0x2d, 0x51, 0x9f, 0xe6, 0xdf,
	0x67, 0x9d, 0xe3, 0xde, 0xee, 0x41, 0x9c, 0xe7, 0x2a, 0x1b, 0x15, 0x64, 0xf4, 0x43, 0xaf, 0x8f,
	0x54, 0x44, 0x7a, 0xa0, 0xcf, 0x0e, 0xd2, 0x2f, 0x3d, 0xe9, 0xfa, 0x7f, 0x97, 0xf6, 0xd8, 0xf9,
	0x16, 0x6b, 0x0e, 0xae, 0x8a, 0xc4, 0xa6, 0xe4, 0x0d, 0xbf, 0x7d, 0x6d, 0x3a, 0x8a, 0x1b, 0x31,
	0xc4, 0xc6, 0x9f, 0xb2, 0xb6, 0x90, 0x2e, 0x35, 0x0a, 0x34, 0x69, 0xfe, 0xb2, 0x8a, 0x26, 0x66,
	0x6c, 0x90, 0x7c, 0x3b, 0x23, 0xa3, 0xa7, 0x79, 0x81, 0x5e, 0x5c, 0x72, 0xc9, 0xe7, 0xa1, 0xf8,
	0x87, 0x8c, 0xbd, 0x8a, 0x27, 0xb2, 0xc8, 0x63, 0x50, 0xdb, 0xbc, 0x66, 0x43, 0x45, 0x24, 0x1b,
	0x3c, 0x6e, 0x68, 0xa5, 0xbb, 0xf2, 0x42, 0x25, 0xb2, 0x1c, 0x95, 0x0f, 0x3c, 0x41, 0x47, 0x29,
	0x5b, 0x29, 0xf1, 0xf1, 0x27, 0x6c, 0x79, 0x20, 0x93, 0x44, 0x4f, 0x72, 0x1a, 0x92, 0xdc, 0x13,
	0x21, 0x8a, 0x28, 0x59, 0xf8, 0x13, 0xf6, 0x00, 0x72, 0xfa, 0xac, 0xe8, 0x1b, 0x9d, 0xc7, 0x23,
	0x57, 0x41, 0x6d, 0x34, 0xe2, 0x3a, 0x01, 0x8c, 0x3d, 0x88, 0x8b, 0x73, 0x39, 0x04, 0xc3, 0x60,
	0x6c, 0x62, 0x5f, 0xf0, 0x50, 0xfc, 0x31, 0x5b, 0x29, 0xf3, 0xde, 0xf1, 0x74, 0x90, 0x67, 0x1e,
	0xc9, 0xd7, 0x18, 0xc3, 0xd2, 0xf5, 0xdb, 0xae, 0x87, 0xe1, 0x5b, 0xac, 0xd5, 0xcb, 0xac, 0x4c,
	0xc5, 0xd0, 0x86, 0x2b, 0x68, 0xc4, 0x5b, 0x7e, 0xd0, 0x89, 0x24, 0x2a, 0xa6, 0xd5, 0xef, 0xb2,
	0x8e, 0x17, 0xd0, 0xcf, 0x34, 0x9d, 0xdf, 0xab, 0xd6, 0x00, 0x60, 0x1a, 0x4e, 0x27, 0x93, 0x52,
	0xd0, 0x01, 0xc0, 0x50, 0xae, 0x0c, 0x37, 0x33, 0xfc, 0x8c, 0xdd, 0x9d, 0x4f, 0x46, 0x9c, 0x16,
	0xba, 0xb0, 0x55, 0xeb, 0x27, 0x08, 0x93, 0x45, 0x67, 0x36, 0x56, 0x99, 0x34, 0xd5, 0x14, 0xf0,
	0x51, 0xd8, 0xe8, 0x60, 0xf8, 0x07, 0x48, 0xc2, 0x73, 0xf4, 0x01, 0xe9, 0xaf, 0xf2, 0xe2, 0xb6,
	0xb6, 0x89, 0x19, 0x58, 0x9f, 0xd5, 0x71, 0xf4, 0xeb, 0x1a, 0xeb, 0x78, 0xa9, 0x72, 0x5b, 0xad,
	0xa3, 0xae, 0xba, 0xa7, 0xeb, 0x21, 0x5b, 0x3a, 0x88, 0x3f, 0xd1, 0x6e, 0xbb, 0x08, 0x84, 0x03,
	0x10, 0xab, 0x32, 0x6d, 0xa8, 0xda, 0x1d, 0x00, 0x9d, 0xef, 0x85, 0x4a, 0xe5, 0x81, 0x1e, 0x4a,
	0xcc, 0xfe, 0x15, 0x51, 0xc1, 0xe5, 0xfc, 0x6b, 0x5e, 0x9b, 0x7f, 0xcb, 0xd5, 0xfc, 0x8b, 0xfe,
	0x5e, 0x27, 0xf3, 0x66, 0x35, 0xf5, 0x9d, 0x59, 0xd6, 0xd7, 0xae, 0x55, 0xae, 0xa3, 0xb8, 0x02,
	0x5b, 0xcc, 0x7d, 0xd8, 0x55, 0xe5, 0x44, 0x9b, 0x2b, 0x5a, 0x9e, 0xfc, 0x6a, 0x71, 0x04, 0x41,
	0x0c, 0x7c, 0x9d, 0x05, 0x3b, 0xfd, 0x63, 0x5a, 0x9f, 0xee, 0xfa, 0x8b, 0x4d, 0xff, 0x58, 0x00,
	0x89, 0x7f, 0x91, 0x35, 0xfa, 0x30, 0x8e, 0x5d, 0x23, 0xb8, 0xe7, 0xb1, 0x00, 0x5a, 0x20, 0x11,
	0xaa, 0x6d, 0x3b, 0xd5, 0xc9, 0x79, 0xef, 0x10, 0x8d, 0x9f, 0xaf, 0x36, 0xa2, 0x88, 0x92, 0x85,
	0xbf, 0x60, 0x77, 0xf7, 0xa6, 0x23, 0x99, 0xc7, 0x23, 0xb9, 0xef, 0x16, 0x24, 0xd7, 0x0e, 0x42,
	0x4f, 0x68, 0x8e, 0x81, 0x0c, 0x5c, 0x90, 0x82, 0x5b, 0x5f, 0x49, 0x7b, 0xa9, 0xcd, 0x39, 0x6d,
	0x66, 0xfe, 0xad, 0x44, 0x11, 0x25, 0x4b, 0xf4, 0xd7, 0x32, 0x0b, 0xc8, 0xf4, 0x87, 0xd0, 0x9c,
	0x27, 0xca, 0xad, 0x32, 0x81, 0x70, 0x00, 0xe4, 0xa6, 0x90, 0x85, 0x34, 0x17, 0xae, 0x07, 0xd4,
	0xdd, 0xba, 0xe4, 0xa1, 0x30, 0x37, 0x2f, 0xe3, 0x9c, 0x92, 0x02, 0xcf, 0x90, 0xe9, 0x1f, 0x49,
	0x93, 0xc9, 0x94, 0x92, 0x82, 0x20, 0xd8, 0x0f, 0xdc, 0xe9, 0x68, 0xa7, 0x8f, 0x9e, 0x09, 0xc4,
	0x0c, 0x01, 0xf5, 0x0f, 0xd2, 0xb9, 0xca, 0xe0, 0xdb, 0xa5, 0x89, 0x43, 0xdd, 0xc3, 0xf0, 0xaf,
	0xb2, 0xfb, 0xbb, 0xaa, 0x80, 0x45, 0xe3, 0xf0, 0xf0, 0xe0, 0x23, 0x95, 0xa6, 0xd2, 0xa0, 0xa1,
	0x2d, 0x71, 0x0d, 0x1f, 0xfd, 0xa5, 0xc6, 0x5a, 0x65, 0xe0, 0xe0, 0x39, 0x83, 0x71, 0x6c, 0x30,
	0x71, 0x40, 0x29, 0x41, 0x60, 0xf2, 0x8f, 0xa6, 0xda, 0xc6, 0x64, 0x96, 0x03, 0x80, 0xbb, 0x2f,
	0x8d, 0xd2, 0x43, 0xda, 0x2b, 0x08, 0x82, 0x1d, 0x53, 0xc8, 0x38, 0xb5, 0x6a, 0x22, 0xc5, 0x34,
	0x83, 0x1f, 0xb2, 0x6e, 0x11, 0x0d, 0xcb, 0x5b, 0x89, 0x22, 0x4d, 0x4b, 0xa8, 0x69, 0x01, 0x0b,
	0xae, 0xdb, 0xc9, 0xa7, 0x05, 0xad, 0xd8, 0x78, 0x06, 0xdc, 0x81, 0x9c, 0xb8, 0xdd, 0xba, 0x2d,
	0xf0, 0x1c, 0x5d, 0xd2, 0x1e, 0x77, 0x82, 0xdb, 0x25, 0x55, 0x6d, 0x55, 0x8d, 0xb5, 0x1b, 0xab,
	0xb1, 0xee, 0x57, 0xe3, 0x23, 0xd6, 0x74, 0xb2, 0xd4, 0x41, 0x08, 0x02, 0x8f, 0xef, 0xcb, 0xf8,
	0x8c, 0x68, 0x0d, 0xa4, 0x79, 0x98, 0xe8, 0x98, 0xbd, 0x85, 0x17, 0x1f, 0x8d, 0x8d, 0xb6, 0x36,
	0x95, 0xff, 0xc3, 0xd5, 0x9c, 0x35, 0x44, 0x6c, 0x65, 0xb9, 0xa3, 0xc1, 0x39, 0xfa, 0x67, 0xc0,
	0xee, 0xf8, 0xa5, 0xe0, 0xbd, 0xaf, 0xf6, 0x1f, 0xde, 0x57, 0x5f, 0x7c, 0x1f, 0xef, 0xb2, 0x3b,
	0xbe, 0x4f, 0x6e, 0x98, 0xe8, 0x3e, 0x99, 0xca, 0x66, 0x4e, 0x84, 0x1f, 0xb3, 0xb7, 0x4b, 0xeb,
	0x60, 0x1a, 0x6d, 0xe7, 0x05, 0xe9, 0x6a, 0xa0, 0xae, 0xcf, 0x7b, 0xba, 0xe6, 0xbd, 0x40, 0xda,
	0x6e, 0x96, 0xe6, 0x27, 0xec, 0x51, 0x49, 0x38, 0x31, 0xca, 0xca, 0x99, 0xde, 0xa5, 0x4f, 0xa7,
	0xf7, 0x16, 0x71, 0x5f, 0x31, 0xdc, 0xd8, 0x3b, 0xec, 0x0f, 0x48, 0x71, 0xf3, 0x33, 0x2a, 0x9e,
	0x17, 0xe7, 0x3f, 0x61, 0xef, 0xcc, 0x5d, 0xe9, 0x69, 0x5e, 0xfe, 0x74, 0x9a, 0x6f, 0x93, 0x8f,
	0xde, 0x67, 0xed, 0xaa, 0x43, 0xde, 0xdc, 0x67, 0xa2, 0x5f, 0x94, 0xdf, 0x2a, 0x7e, 0x23, 0x07,
	0xde, 0x6e, 0x9a, 0xea, 0x4b, 0xfa, 0x28, 0x76, 0xc0, 0xff, 0x3d, 0x9b, 0x1e, 0xb1, 0x66, 0x37,
	0xc1, 0xff, 0x47, 0xdc, 0x5e, 0x46, 0x50, 0x94, 0x52, 0x56, 0x52, 0x87, 0x84, 0x4d, 0x76, 0x27,
	0x8d, 0x8b, 0xa2, 0x1a, 0xd8, 0x25, 0xc8, 0xb7, 0x19, 0xeb, 0x1b, 0xa5, 0x8d, 0xfb, 0x0c, 0x76,
	0x0b, 0xe8, 0xbb, 0x0b, 0xbb, 0x88, 0x39, 0x8b, 0x13, 0x49, 0x5c, 0x57, 0xe5, 0x12, 0x37, 0x93,
	0x8a, 0x5e, 0x30, 0x7e, 0xbd, 0xb3, 0xc3, 0xdc, 0xec, 0xc7, 0x23, 0x59, 0xc0, 0xb4, 0x77, 0xf3,
	0xb8, 0x82, 0x67, 0x9e, 0x73, 0xdf, 0x40, 0xe4, 0xb9, 0x3d, 0xf6, 0xe8, 0xe6, 0x3b, 0xc1, 0x4f,
	0xb0, 0x1c, 0x94, 0x73, 0x1d, 0xce, 0xa8, 0x9f, 0xe8, 0x54, 0x4f, 0x15, 0x1c, 0xfd, 0xb2, 0x46,
	0x0e, 0x28, 0xd7, 0xc0, 0xc7, 0x6c, 0x65, 0x57, 0x9e, 0xc5, 0xd3, 0xd4, 0x76, 0x13, 0xef, 0x23,
	0x6a, 0x1e, 0x09, 0x5c, 0x5d, 0x93, 0x8c, 0x95, 0x95, 0x89, 0x9d, 0x1a, 0x59, 0x7e, 0x1f, 0xcc,
	0x23, 0xf9, 0x37, 0x59, 0x0b, 0x76, 0xb1, 0x38, 0x4d, 0x0b, 0x2a, 0xd3, 0xb9, 0x0d, 0xd4, 0x91,
	0xca, 0xcf, 0x91, 0x92, 0x33, 0x52, 0xec, 0x9e, 0xff, 0xa2, 0xae, 0x19, 0x81, 0x17, 0x7a, 0xd9,
	0x50, 0xbe, 0xa6, 0x5e, 0xee, 0x00, 0xc0, 0x7e, 0x5c, 0x6d, 0x72, 0x0d, 0xe1, 0x00, 0xb0, 0x16,
	0x0f, 0x47, 0x97, 0x9a, 0x1a, 0x50, 0x05, 0xf3, 0xbb, 0xac, 0x7e, 0x98, 0xd3, 0x37, 0x73, 0xfd,
	0x30, 0x8f, 0x26, 0xa5, 0xf1, 0xee, 0x6e, 0xd0, 0x88, 0xab, 0x15, 0x7d, 0x24, 0x3b, 0xc0, 0xe5,
	0x4e, 0x35, 0x0a, 0x31, 0x77, 0xd0, 0x09, 0x5b, 0xf4, 0x6d, 0xe4, 0x4c, 0x7b, 0xfb, 0xfa, 0x72,
	0xdd, 0x35, 0xe5, 0xd7, 0x08, 0x32, 0x46, 0xdf, 0x62, 0x2b, 0x73, 0x6b, 0x2b, 0xb8, 0x71, 0xff,
	0xd9, 0x4e, 0x9c, 0x8c, 0xe5, 0x20, 0x19, 0xcb, 0x49, 0x5c, 0x3a, 0x7b, 0x0e, 0xb9, 0x7d, 0xff,
	0x5f, 0xff, 0x58, 0xab, 0xfd, 0xf6, 0xcd, 0x5a, 0xed, 0xf7, 0x6f, 0xd6, 0x6a, 0x7f, 0x7c, 0xb3,
	0x56, 0x3b, 0x6d, 0xe2, 0x1f, 0x83, 0xcf, 0xfe, 0x1d, 0x00, 0x00, 0xff, 0xff, 0x44, 0x68, 0x74,
	0x4f, 0x7a, 0x14, 0x00, 0x00,
}
